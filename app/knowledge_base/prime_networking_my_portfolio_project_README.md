# PrimeNetworking Backend 🚀

<p align="left">
  <img src="https://img.shields.io/badge/Status-Ready_for_QA-blue" alt="Status">
  <img src="https://img.shields.io/badge/Version-1.4.0-blueviolet" alt="Version">
  <img src="https://img.shields.io/badge/Build-Passing-brightgreen" alt="Build">
</p>

Это бэкенд-часть проекта **PrimeNetworking**,  
Telegram Mini App для управления контактами с функциями AI.  
Проект готов к MVP, развитие и поддержка сервиса продолжается.  
[Документация Swagger UI](https://primenetworking-backend-f.onrender.com/docs#)

# 🧠 Концепт: умная сетевая телефонная книга

## 📚 Оглавление
- [Стек технологий](#-стек-технологий)
- [Структура проекта](#-структура-проекта)
- [Инструкции и документация](#-инструкции-и-документация)
- [План разработки](#-общий-план-разработки-для-ver-100-updated-2209)

## 🔧 Стек технологий

<p align="left">
  <img src="https://img.shields.io/badge/Python-3.11+-blue.svg" alt="Python version">
  <img src="https://img.shields.io/badge/FastAPI-0.110+-05998b.svg" alt="FastAPI">
  <img src="https://img.shields.io/badge/Uvicorn-ASGI_Server-green.svg" alt="Uvicorn">
  <img src="https://img.shields.io/badge/SQLAlchemy-ORM-blueviolet.svg" alt="SQLAlchemy">
  <img src="https://img.shields.io/badge/PostgreSQL-RDBMS-yellow.svg" alt="PostgreSQL">
  <img src="https://img.shields.io/badge/Alembic-Migrations-orange.svg" alt="Alembic">
  <img src="https://img.shields.io/badge/Pydantic-Data_Validation-cyan.svg" alt="Pydantic">
  <img src="https://img.shields.io/badge/Passlib_Bcrypt-Password_Hashing-red.svg" alt="Passlib & Bcrypt">
  <img src="https://img.shields.io/badge/Playwright-Web_Scraping-brown.svg" alt="Playwright">
  <img src="https://img.shields.io/badge/BeautifulSoup4-HTML_Parsing-purple.svg" alt="BeautifulSoup4">
  <img src="https://img.shields.io/badge/Mistral_AI-AI_Integration-teal.svg" alt="Mistral AI">
  <img src="https://img.shields.io/badge/Pytest-HTTpx_Testing-lightgrey.svg" alt="Pytest & HTTpx">
  <img src="https://img.shields.io/badge/License-MIT-green.svg" alt="License">
  <img src="https://img.shields.io/badge/code%20style-ruff-black.svg" alt="Code style: ruff">
</p>
<details>
<summary>👤 Подробнее</summary>

- **Python 3.12+:** Основной язык разработки.
- **FastAPI:** Высокопроизводительный веб-фреймворк для создания API.
- **Uvicorn:** ASGI-сервер для запуска FastAPI-приложения.
- **SQLAlchemy:** ORM для взаимодействия с базой данных.
- **SQLite:** Используемая реляционная база данных для локальной разработки.
- **Alembic:** Инструмент для управления миграциями схемы базы данных.
- **Pydantic:** Для валидации данных, сериализации и управления настройками.
- **Passlib & Bcrypt:** Для безопасного хеширования паролей.
- **Python-jose:** Для создания и проверки JSON Web Tokens (JWT).
- **Playwright:** Для эмуляции браузера и веб-скрапинга с динамических страниц.
- **BeautifulSoup4:** Для парсинга HTML и извлечения данных.
- **Mistral AI:** Для интеграции моделей генеративного AI.
- **Phonenumbers:** Для валидации и форматирования телефонных номеров.
- **Pytest & HTTpx:** Для написания и запуска автоматизированных тестов.
</details>

## 📁 Структура проекта
```text
PrimeNetworking_Backend/
├── alembic/
│   ├── versions/
│   ├── env.py            # Конфигурация Alembic
│   └── script.py.mako    # Шаблон для генерации миграций
├── app/
│   ├── api/
│   │   ├── dependencies/ # Зависимости для API (проверка ролей, токенов)
│   │   └── routers/
│   │       ├── admin.py
│   │       ├── auth.py
│   │       ├── contacts.py
│   │       └── ... (и другие роутеры)
│   ├── core/
│   │   ├── auth.py
│   │   ├── config.py
│   │   ├── enums.py
│   │   └── security.py
│   ├── db/
│   │   ├── database.py   # Настройка сессии БД
│   │   └── types.py      # Кастомные типы данных для SQLAlchemy
│   ├── services/         # Сервисный слой с бизнес-логикой
│   │   ├── auth_service.py
│   │   ├── contact_service.py
│   │   └── ... (и другие сервисы)
│   ├── __init__.py
│   ├── main.py           # Главная точка входа в приложение FastAPI
│   ├── models.py         # Модели данных SQLAlchemy
│   └── schemas.py        # Схемы Pydantic для валидации данных
├── tests/                # Автоматизированные тесты
│   ├── conftest.py       # Фикстуры для тестов
│   └── test_*.py
├── .env.example          # Пример файла с переменными окружения
├── .gitignore
├── alembic.ini
├── LICENSE
├── pytest.ini            # Конфигурация для Pytest
├── README.md
└── requirements.txt
```

## 📦 Инструкции и документация
<details>
<summary>⚙ Как запустить проект локально</summary>

1.  **Клонируйте репозиторий:**  
    ```bash
    git clone https://github.com/admXADV/PrimeNetworking_backend.git
    cd PrimeNetworking_backend
    ```

2.  **Создание виртуального окружения и установка зависимостей:**  
    Убедитесь, что у вас установлен Python 3.12+ и `pip`.
    ```bash
    python3 -m venv venv
    source venv/bin/activate  # Для Linux/macOS
    # venv\Scripts\activate  # Для Windows
    pip install -r requirements.txt
    ```

3.  **Настройте переменные окружения:**  
    Создайте файл `.env` в корневой папке проекта. Этот файл хранит ваши секретные ключи и не отслеживается Git.
    ```bash
    touch .env
    ```
    Откройте файл `.env` и добавьте в него следующие переменные, заменив значения на ваши:
    ```dotenv
    # ВАЖНО: Пробелы вокруг знака '=' не допускаются.
    # Ключ для работы с AI-моделями Mistral
    MISTRAL_API_KEY="your_mistral_api_key_for_parsing"
    # Ключ для генерации AI-рекомендаций
    MISTRAL_RECOMMENDATION_API_KEY="your_mistral_api_key_for_recommendations"
    # Секретный ключ для генерации JWT-токенов (можно сгенерировать `openssl rand -hex 32`)
    SECRET_KEY="your_super_secret_key_here"
    # Токен вашего Telegram-бота для валидации данных от Mini App
    TELEGRAM_BOT_TOKEN="your_telegram_bot_token_here"
    # Имя пользователя вашего Telegram-бота (без @) для генерации реферальных ссылок
    TELEGRAM_BOT_USERNAME="YourBotUsername"
    # Секретный ключ для защиты эндпоинтов, вызываемых cron-сервисами
    CRON_SECRET_KEY="your_cron_secret_key_here"
    # Публичный URL вашего приложения для установки вебхука Telegram (например, https://your-app.onrender.com)
    APP_PUBLIC_URL="your_public_app_url_here"
    ```

4.  **Установите браузеры для Playwright:**  
    Для работы AI-парсера необходимо скачать браузеры, которыми он будет управлять.
    ```bash
    playwright install
    ```

5.  **Создайте или обновите базу данных:**  
    У вас есть два скрипта для работы с базой данных:

    -   **Для штатного обновления (рекомендуется):**  
        Если вы создали новую миграцию (`alembic revision...`), используйте этот скрипт для безопасного обновления схемы без потери данных. После первого создания БД этим методом, ее нужно будет заполнить тестовыми данными (см. следующий шаг).
    ```bash
    bash upgrade_db.sh
    ```
    -   **Для полного сброса (только при необходимости):**  
        Этот скрипт полностью удалит базу данных, создаст ее с нуля и **автоматически заполнит тестовыми данными**. **Все данные будут потеряны.**
    ```bash
    bash reset_db.sh
    ```
    > **Примечание для разработчика:** Если вы вносите изменения в модели (`app/models.py`), вам необходимо сгенерировать новый файл миграции перед обновлением. Используйте команду:
    > ```bash
    > alembic revision --autogenerate -m "Краткое описание ваших изменений"
    > ```

6.  **(Опционально) Заполните базу тестовыми данными:**  
    Если вы создали базу данных с помощью `upgrade_db.sh` (или она пуста), выполните этот скрипт, чтобы наполнить ее стандартным набором пользователей и контактов.
    ```bash
    python seed.py
    ```

7.  **Запустите приложение:**  
    Теперь для работы приложения достаточно запустить один процесс:
    ```bash
    uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
    ```
    Приложение будет доступно по адресу `http://127.0.0.1:8000/`.  
    Документация API (Swagger UI) будет доступна по адресу `http://127.0.0.1:8000/docs`.
</details>

<details>
<summary>👤 Сводка по тестовым сущностям</summary>

**Цель:** Набор данных имитирует небольшую, но активную группу пользователей, чтобы можно было протестировать все ключевые сценарии: от простого отображения контактов до сложных взаимодействий, таких как общие связи и AI-анализ.

#### 1. Основные пользователи (могут входить в систему)

Эти сущности являются полноценными пользователями приложения. Для входа в систему от их имени используйте отладочный эндпоинт `GET /api/auth/get-debug-token`, подставляя соответствующий `telegram_id`.
Обратите внимание, что все пути API начинаются с префикса `/api`.

-   **`Neo`**
    -   **ID для входа:** `telegram_id=1`
    -   **Роль:** Главный тестовый пользователь. Владелец большинства контактов.
    -   **Особенности:**
        -   Его собственная карточка (`/persons/me`) частично заполнена данными (`city`, `skills`, `hobbies`).
        -   Создал два шаблона кастомных полей: "Источник" и "Статус".
        -   Имеет в контактах как других пользователей (`Trinity`), так и "заглушки" (`Morpheus`, `Cypher`, `Agents`).

-   **`Trinity`**
    -   **ID для входа:** `telegram_id=2`
    -   **Роль:** Второй тестовый пользователь.
    -   **Особенности:**
        -   Имеет общие контакты с Neo (например, `Morpheus`), что позволяет тестировать эндпоинт `/shared-contacts`.
        -   Ее карточка в контактах у Neo обогащена данными от AI (`hobbies`, `skills`).

#### 2. Ключевые контакты (сущности в "телефонной книге")

Это контакты, которые принадлежат пользователям. Они не могут входить в систему, но служат для демонстрации различных функций.

-   **`Morpheus`**
    -   **Тип:** Контакт-заглушка, созданный по номеру телефона.
    -   **Назначение:** Демонстрация **общих контактов**. Он есть и у Neo, и у Trinity.

-   **`Cypher`**
    -   **Тип:** Контакт-заглушка, созданный по `username`.
    -   **Назначение:** Демонстрация **кастомных полей**. У его карточки в контактах Neo заполнены поля "Источник" (`Nebuchadnezzar Crew`) и "Статус" (`Questionable`).

-   **`Agent Smith` (1, 2, 3)**
    -   **Тип:** Три разных контакта-заглушки.
    -   **Назначение:** Демонстрация **разных способов создания контактов**: по `telegram_id`, по `phone_number` и по `username`.

</details>

<details>
<summary>💡 Руководство по тестированию API в Swagger UI</summary>

Это пошаговое руководство поможет протестировать все ключевые сценарии: от аутентификации до AI-анализа.

### Шаг 0: Подготовка

1.  **Запустите приложение**, как описано в `README.md`:
    ```bash
    uvicorn app.main:app --reload
    ```
2.  **Откройте Swagger UI** в вашем браузере по адресу: `http://127.0.0.1:8000/docs`.

### Часть 1: Аутентификация и Профиль

#### 1.1. Получение JWT-токена (симуляция входа)

-   **Эндпоинт:** `GET /api/auth/get-debug-token`
-   **Описание:** Создает тестового пользователя (если его нет) и возвращает JWT-токен для него.
-   **Действия:**
    1.  В Swagger UI разверните секцию `Аутентификация`.
    2.  Найдите эндпоинт `GET /api/auth/get-debug-token`.
    3.  Нажмите "Try it out". Можете оставить `telegram_id` по умолчанию (`1`).
    4.  Нажмите "Execute".
-   **Ожидаемый результат:**
    -   `Code 200 OK`.
    -   В "Response body" вы получите `access_token`. **Скопируйте значение токена** (длинную строку без кавычек).

#### 1.2. Авторизация в Swagger UI

-   **Действия:**
    1.  Нажмите зеленую кнопку **"Authorize"** в правом верхнем углу страницы.
    2.  В появившемся окне в поле **"Value"** вставьте `Bearer ` и через пробел скопированный `access_token`. Пример: `Bearer eyJhbGciOiJIUzI1Ni...`
    3.  Нажмите **"Authorize"**, затем **"Close"**.
-   **Ожидаемый результат:**
    -   Иконки замков рядом с эндпоинтами станут закрытыми. Теперь вы можете выполнять запросы от имени аутентифицированного пользователя.

#### 1.3. Проверка профиля

-   **Эндпоинт:** `GET /api/persons/me`
-   **Действия:**
    1.  В секции `Профиль` найдите `GET /api/persons/me`.
    2.  Нажмите "Try it out", затем "Execute".
-   **Ожидаемый результат:**
    -   `Code 200 OK`.
    -   В "Response body" будут данные вашего профиля, включая `person_details` и `self_contact_card`.

### Часть 2: Управление контактами и кастомными полями

#### 2.1. Создание шаблона кастомного поля

-   **Эндпоинт:** `POST /api/custom-fields/`
-   **Действия:**
    1.  В секции `Пользовательские поля (Шаблоны)` найдите `POST /api/custom-fields/`.
    2.  Нажмите "Try it out". Введите данные для поля, например:
        ```json
        {
          "field_name": "Проект",
          "field_type": "text"
        }
        ```
    3.  Нажмите "Execute". **Запомните `id`** созданного поля из ответа.
-   **Ожидаемый результат:** `Code 201 Created`.

#### 2.2. Создание нового контакта

-   **Эндпоинт:** `POST /api/contacts/`
-   **Действия:**
    1.  В секции `Контакты` найдите `POST /api/contacts/`.
    2.  Нажмите "Try it out". Введите данные контакта:
        ```json
        {
          "first_name": "Илон Маск",
          "telegram_id": 12345
        }
        ```
    3.  Нажмите "Execute". **Запомните `id`** созданного контакта.
-   **Ожидаемый результат:** `Code 201 Created`.

#### 2.3. Добавление значения кастомного поля к контакту

-   **Эндпоинт:** `POST /api/contacts/{contact_id}/custom_field_values/`
-   **Действия:**
    1.  Найдите `POST /api/contacts/{contact_id}/custom_field_values/`.
    2.  Нажмите "Try it out". Введите `contact_id` из шага 2.2.
    3.  В "Request body" укажите `field_id` (из шага 2.1) и значение:
        ```json
        {
          "field_id": 1,
          "value": "Матрица"
        }
        ```
    4.  Нажмите "Execute".
-   **Ожидаемый результат:** `Code 201 Created`.

### Часть 3: Тестирование AI-пайплайна

#### 3.1. Запуск AI-анализа

-   **Эндпоинт:** `POST /api/contacts/{contact_id}/parse-social-media`
-   **Действия:**
    1.  Найдите `POST /api/contacts/{contact_id}/parse-social-media`.
    2.  Нажмите "Try it out". Введите `contact_id` вашего контакта.
    3.  В "Request body" введите URL для анализа:
        ```json
        {
          "url": "https://ru.wikipedia.org/wiki/Hulk_Hogan"
        }
        ```
    4.  Нажмите "Execute".
-   **Ожидаемый результат:** `Code 202 Accepted`. Анализ запущен в фоновом режиме.

#### 3.2. Получение AI-предложений

-   **Эндпоинт:** `GET /api/contacts/{contact_id}/suggestions`
-   **Действия:**
    1.  Подождите 20-30 секунд.
    2.  Найдите `GET /api/contacts/{contact_id}/suggestions`.
    3.  Нажмите "Try it out", введите `contact_id` и нажмите "Execute".
-   **Ожидаемый результат:** `Code 200 OK`. В ответе будет список предложений. **Запомните `id`** одного из предложений.

#### 3.3. Предпросмотр результата слияния

-   **Эндпоинт:** `GET /api/contacts/{contact_id}/suggestions/{suggestion_id}/preview`
-   **Действия:**
    1.  Найдите `GET .../preview`.
    2.  Нажмите "Try it out". Введите `contact_id` и `suggestion_id`.
    3.  Нажмите "Execute".
-   **Ожидаемый результат:** `Code 200 OK`. В ответе вы увидите, как будет выглядеть контакт **после** применения предложения, но без сохранения в базу.

#### 3.4. Подтверждение и сохранение

-   **Эндпоинт:** `POST /api/contacts/{contact_id}/suggestions/{suggestion_id}/confirm`
-   **Действия:**
    1.  Найдите `POST .../confirm`.
    2.  Нажмите "Try it out". Введите `contact_id` и `suggestion_id`.
    3.  Нажмите "Execute".
-   **Ожидаемый результат:** `Code 200 OK`. В ответе будет карточка контакта с примененными данными.

Тестирование завершено! Вы проверили полный цикл работы с API.

</details>

<details>
<summary>🤖 Как запустить автоматизированные тесты (pytest)</summary>

Для проверки корректности работы логики приложения используются автоматизированные тесты, разделенные на группы с помощью маркеров.

-   **Запуск всех тестов:**  
    Выполняет полный набор тестов.
    ```bash
    pytest
    ```

-   **Запуск всех тестов с выводом логов (`print`):**  
    Флаг `-s` позволяет видеть отладочные выводы в реальном времени.
    ```bash
    pytest -s
    ```

-   **Запуск тестов, не требующих внешних API:**  
    Эта команда выполнит все быстрые unit- и интеграционные тесты, которые не обращаются к внешним AI-сервисам. Рекомендуется для частой проверки.
    ```bash
    pytest -m "not ai and not ai_rec"
    ```

-   **Запуск только тестов AI-парсинга:**  
    Эта команда выполнит только тесты, которые проверяют логику парсинга социальных сетей. Требует наличия `MISTRAL_API_KEY` в `.env` файле.
    ```bash
    pytest -m "ai"
    ```

-   **Запуск только тестов AI-рекомендаций:**  
    Эта команда выполнит только тесты для новой функции генерации подсказок. Не требует реального API-ключа, так как использует моки.
    ```bash
    pytest -m "ai_rec"
    ```
</details>

<details>
<summary>📋 Реализация первого этапа: Ядро и AI-пайплайн</summary>

На этом этапе был заложен фундамент приложения и реализован полный цикл работы с AI.

#### **I. Ядро приложения и управление контактами:**

-   **Архитектура данных:** Внедрена масштабируемая архитектура `Person` -> `TelegramAccount` -> `Contact`, обеспечивающая гибкость и целостность данных.
-   **Бесшовная аутентификация:** Реализован механизм входа через Telegram Mini App с валидацией `initData`.
-   **Продвинутое управление пользователями:**
    -   Автоматическое создание `Person` и `TelegramAccount` при первом входе.
    -   Логика слияния "заглушек" с верифицированными аккаунтами.
    -   "Протокол Разрешения Парадоксов": корректная обработка смены владельца номера телефона.
-   **Гибкое управление контактами:**
    -   Полный CRUD для персонализированных карточек контактов.
    -   Создание контактов-заглушек по `telegram_id` или `phone_number`.
    -   Механизм получения списка общих контактов.
-   **Кастомизация:** Реализована система создания пользовательских полей (шаблонов) и добавления значений к контактам.
-   **Валидация данных:** Внедрена автоматическая нормализация и валидация телефонных номеров по стандарту E.164.

#### **II. Интеграция AI-пайплайна:**

-   **Сбор данных:** Разработан модуль на Playwright и BeautifulSoup для сбора текстового контента и URL изображений с веб-страниц.
-   **AI-анализ:**
    -   Интегрирован клиент для Mistral AI.
    -   Реализован анализ текста для извлечения структурированных данных.
    -   Реализован двухэтапный анализ изображений: получение текстового описания и его последующее структурирование.
-   **Полный цикл предложений:**
    -   Запуск AI-анализа в фоновом режиме без блокировки интерфейса.
    -   Сохранение результатов анализа в базу данных.
    -   Эндпоинт для предпросмотра результата слияния данных контакта и AI-предложения.
    -   Эндпоинт для подтверждения и сохранения предложений в карточку контакта.
-   **Умное слияние данных:** Реализована логика синтеза данных из текстового и визуального анализаторов с учетом приоритетов и конкатенации полей.

</details>

<details>
<summary>📋 Реализация второго этапа, п. 1: Отслеживание событий, планирование и уведомления</summary>

На этом этапе была реализована многофункциональная система событий и уведомлений, построенная на синхронной архитектуре для совместимости с облачными платформами.

#### **I. Гибкое управление событиями:**

-   **Полный CRUD для событий:** Реализованы все операции (создание, чтение, обновление, удаление) для событий, которые привязаны к контактам и их владельцам.
-   **Поддержка повторяющихся событий:** Внедрен механизм для установки частоты повторения (`один раз`, `ежедневно`, `еженедельно`, `ежемесячно`, `ежегодно`).
-   **Умное планирование:** Система корректно обрабатывает пограничные случаи, такие как создание событий в прошлом: одноразовые игнорируются, а повторяющиеся автоматически перепланируются на первую актуальную дату.

#### **II. Надежная система уведомлений:**

-   **Выделенная таблица `scheduled_notifications`:** Каждое уведомление (основное и предварительное) хранится как отдельная задача, что обеспечивает прозрачность и отказоустойчивость.
-   **Централизация логики:** Вся логика по обработке уведомлений — поиск событий, формирование текста, отправка через Telegram и перепланирование — была объединена в одной сервисной функции `process_and_send_due_notifications`.
-   **Синхронная модель:** Вместо платных фоновых воркеров используется защищенный API-эндпоинт (`/api/tasks/process-notifications`), вызываемый внешним cron-сервисом.
-   **Интеллектуальная логика "тихих" папок:** Уведомление о событии пропускается (получает статус `SKIPPED`) только в том случае, если **все** его участники находятся в "тихих" папках.
-   **Политика хранения данных:** Реализована автоматическая очистка старых (старше 90 дней) обработанных уведомлений для поддержания производительности базы данных.
-   **Защищенный API-эндпоинт:** Создана точка входа `POST /api/tasks/process-notifications`, предназначенная для вызова внешними cron-сервисами (например, `cron-job.org`).
-   **Безопасность:** Эндпоинт защищен секретным ключом, который должен передаваться в заголовке `X-Cron-Secret`, что предотвращает несанкционированный запуск.

</details>

<details>
<summary>📋 Реализация второго этапа, п. 2: Персонализированные рекомендации от ИИ</summary>

На этом этапе была реализована функция "умных подсказок", которая помогает пользователям инициировать общение с контактами. Система генерирует контекстные идеи для начала разговора на основе данных из карточки контакта.

#### **I. Модульная и изолированная архитектура:**

-   **Новый API-эндпоинт:** Создана точка входа `POST /api/ai/recommendation`, которая принимает название и значение поля контакта и возвращает сгенерированную текстовую рекомендацию.
-   **Изолированный сервис:** Логика генерации вынесена в отдельный модуль `app/services/ai_recommendation_service.py`, который не затрагивает существующий сложный пайплайн AI-парсинга. Это обеспечивает чистоту кода и простоту поддержки.
-   **Выделенная конфигурация:** Для новой функции используется отдельный API-ключ `MISTRAL_RECOMMENDATION_API_KEY`, что позволяет разделить квоты и мониторинг использования AI.

#### **II. Гибкое взаимодействие с фронтендом:**

-   **Stateless-дизайн:** Бэкенд не хранит состояние диалога. Вся логика управления находится на стороне фронтенда.
-   **Управление уникальностью:** Фронтенд может передавать в запросе список уже показанных рекомендаций (`previous_recommendations`), чтобы AI каждый раз генерировал новый, уникальный ответ.
-   **Поддержка множественных значений:** Для полей, содержащих несколько значений через запятую (например, "Хобби"), фронтенд может управлять, для какого именно значения генерировать подсказку, передавая `current_index` (type = int).

</details>

<details>
<summary>📋 Реализация третьего этапа, п. 1: Система оплаты подписки</summary>

На этом этапе была реализована полнофункциональная система управления подписками, включая интеграцию с платежным API, панель администрирования и автоматизацию процессов.

#### **I. Ядро системы подписок:**

-   **Модели данных:** Введены новые модели `SubscriptionTier`, `Payment` и `SubscriptionHistory` для хранения тарифов, отслеживания платежей и ведения журнала аудита.
-   **Двухэтапная логика оплаты:** Реализован механизм расчета стоимости апгрейда/продления (`/calculate-upgrade`) и эндпоинт для подтверждения и инициации оплаты (`/confirm-change`).
-   **Умная активация:** Система корректно обрабатывает новые покупки, продления и апгрейды (включая бесплатные за счет кредита за неиспользованное время).

#### **II. Интеграция с API Банка Точка и автоматизация:**

-   **Генерация QR-кодов:** Реализована интеграция с API банка для генерации СБП QR-кодов.
-   **Пакетная проверка статусов:** Создан эндпоинт `/tasks/check-pending-subscriptions`, который за один API-вызов проверяет статусы всех ожидающих платежей.
-   **Мгновенная активация через вебхуки:** Реализован эндпоинт `/webhooks/tochka/payment-status` для приема уведомлений от банка с криптографической проверкой подписи JWT.

#### **III. Панель администрирования:**

-   **Полный CRUD:** Создан защищенный роутер `/admin`, предоставляющий администраторам полный набор инструментов для управления пользователями, тарифами и платежами.
-   **Ручное управление:** Реализованы эндпоинты для ручной проверки статуса платежа и принудительной активации подписки.
-   **Журнал аудита:** Администраторы могут просматривать полную историю изменений подписки для любого пользователя.

#### **IV. Тестирование:**

-   **Комплексное покрытие:** Весь новый функционал покрыт набором unit- и интеграционных тестов.
-   **Утилита для ручного тестирования:** Создан скрипт `4dev/utils/generate_webhook_jwt.py` для легкого тестирования эндпоинта вебхуков вручную.

</details>

<details>
<summary>📋 Реализация третьего этапа, п. 2: Система бонусов за активности</summary>

На этом этапе была реализована гибкая система поощрения пользователей за полезные действия в приложении. Система переведена с ежедневной проверки на мгновенное начисление бонусов в ответ на активность.

#### **I. Событийно-ориентированная модель:**

-   **Мгновенное начисление:** Вместо устаревшей проверки раз в сутки, бонусы теперь начисляются в реальном времени, как только пользователь создает или обновляет контакт (`create_contact`, `update_contact`) или любой из его вложенных элементов (телефоны, адреса и т.д.).
-   **Разделение логики:** Старая функция `calculate_daily_bonus` была переработана и теперь отвечает **только за списание штрафа** за неактивность, что делает систему более логичной и предсказуемой.

#### **II. Гибкое управление и конфигурация:**

-   **Глобальный "тумблер":** Вся система бонусов за активность управляется одной переменной в конфигурации — `ENABLE_ACTIVITY_BONUS_SYSTEM`. Это позволяет включать или отключать ее без изменения кода.
-   **Настраиваемые значения:** Размеры начислений (`ACTIVITY_BONUS_ACCRUAL_AMOUNT`) и списаний (`ACTIVITY_PENALTY_DEDUCTION_AMOUNT`) вынесены в `config.py`, что позволяет легко настраивать "экономику" приложения.

#### **III. Прозрачность и тестирование:**

-   **Новый тип транзакции:** Для всех начислений за активность используется уникальный тип `CONTACT_ACTIVITY_BONUS`, что обеспечивает прозрачность в истории транзакций пользователя.
-   **Полное покрытие тестами:** Новая логика полностью покрыта автоматическими тестами, которые проверяют как успешное начисление, так и корректную работу "тумблера" и логики списания штрафов.

</details>

<details>
<summary>📋 Реализация третьего этапа, п. 3: Реферальная двухуровневая система</summary>

На этом этапе была реализована полнофункциональная двухуровневая реферальная система, позволяющая пользователям зарабатывать бонусы, приглашая других, и использовать их для оплаты подписки.

#### **I. Двухуровневая реферальная модель:**

-   **Бонусы за L1 и L2:** Пользователи получают бонусы не только за платежи своих прямых рефералов (1-й уровень), но и за платежи тех, кого пригласили их рефералы (2-й уровень).
-   **Процент зависит от тарифа:** Процент бонуса, который получает реферер, зависит от **его собственного тарифа** (`base` или `vip`), что мотивирует пользователей приобретать подписку.

#### **II. Полный жизненный цикл реферала:**

-   **Генерация ссылки:** Любой пользователь может сгенерировать свою статичную реферальную ссылку через эндпоинт `/api/bonus_system/generate-link`.
-   **Надежное отслеживание:** Система переведена на стандартный механизм Telegram Deep Linking (`?start=...`). При переходе по ссылке пользователь попадает в чат с ботом, где система надежно фиксирует реферальную связь еще до полной регистрации в приложении.
-   **Автоматическая привязка:** При первом входе нового пользователя в Mini App, система автоматически находит предварительно созданную реферальную запись и связывает его с пригласителем, а также строит цепочку 2-го уровня.
-   **Автозаполнение контакта:** Если у реферера включена соответствующая опция, его карточка контакта автоматически создается у нового пользователя, что улучшает пользовательский опыт.
-   **Начисление бонусов:** После успешной оплаты подписки рефералом, сервис `process_referral_payment` автоматически рассчитывает и начисляет бонусы реферерам 1-го и 2-го уровней. Бонус рассчитывается от **реально оплаченной суммы**.

#### **III. Экономика и API для пользователя:**

-   **Применение бонусов:** Пользователи могут применять накопленные бонусы для получения скидки при оплате своей подписки через эндпоинты `/api/subscriptions/calculate-with-bonus` и `/api/subscriptions/confirm-change`.
-   **Информационные эндпоинты:** Реализован набор API для управления реферальной программой:
    -   `GET /api/bonus_system/my-stats`: Получение статистики по количеству рефералов и заработанным бонусам.
    -   `GET /api/bonus_system/my-network`: Просмотр своей реферальной сети (кто пригласил тебя и кого пригласил ты).
    -   `GET /api/bonus_system/history`: Просмотр полной истории начислений и списаний бонусов.

</details>

<details>
<summary>📋 Реализация четвертого этапа, п. 1: Настройка уведомлений</summary>

На этом этапе была реализована гибкая система управления уведомлениями, позволяющая пользователям детально настраивать, какие оповещения они хотят получать, и снижать информационный шум.

#### **Гибкая система настроек уведомлений:**

-   **Полный контроль пользователя:** Реализованы эндпоинты (`GET` и `PATCH /api/profile/notification-settings`), позволяющие пользователю детально настраивать, какие уведомления он хочет получать.
-   **Управление системными уведомлениями:** Пользователь может включать или отключать уведомления о важных событиях аккаунта, таких как изменение статуса подписки.
-   **"Тихие" папки:** Добавлена возможность отключать напоминания о событиях для контактов, находящихся в определенных папках, что позволяет снизить информационный шум.
-   **Интеллектуальная отправка:** Система больше не отправляет лишних уведомлений, если администратор сохраняет профиль пользователя без внесения фактических изменений.
-   **Интерактивность:** Уведомления стали более полезными. Например, сообщение об истечении подписки теперь содержит кнопку "Оформить подписку" с прямой ссылкой в нужный раздел приложения.

</details>

<details>
<summary>📋 Реализация четвертого этапа, п. 2: Безопасность профиля (PIN-код)</summary>

На этом этапе была реализована многоуровневая система защиты аккаунта с помощью PIN-кода, включая защиту от подбора и сессии с повышенными привилегиями для выполнения чувствительных операций.

#### **Безопасность профиля (PIN-код):**

-   **Полный жизненный цикл PIN-кода:** Реализованы эндпоинты для установки, проверки и удаления 6-значного цифрового PIN-кода.
-   **Надежное хранение:** PIN-коды никогда не хранятся в открытом виде, используется надежный алгоритм хеширования `bcrypt`.
-   **Защита от подбора:** Внедрен механизм блокировки после нескольких неудачных попыток ввода.
-   **Сессия с повышенными привилегиями:** После успешного ввода PIN-кода пользователь получает временный `elevation_token`, который требуется для выполнения чувствительных операций (например, удаление PIN-кода), что повышает безопасность.
</details>

<details>
<summary>📋 Реализация четвертого этапа, п. 3: Обратная связь и Поддержка</summary>

На этом этапе была реализована интерактивная система поддержки, позволяющая пользователям общаться с администрацией через Telegram, а администраторам — управлять обращениями и вести диалог прямо из чата поддержки.

#### **Система обратной связи и поддержки:**

#### **I. Создание обращений и администрирование:**
- Реализован полный цикл управления тикетами: от создания пользователем через API до просмотра и редактирования в панели администратора (`/admin/support-tickets`).

#### **II. Интерактивный чат через Telegram:**
-   **Двусторонняя связь:** Создан полноценный чат между пользователем и службой поддержки. Администраторы могут отвечать на тикеты прямо из чата поддержки в Telegram, а пользователи — вести переписку с ботом в личных сообщениях.
-   **Хранение истории:** Вся переписка по каждому тикету сохраняется в базе данных и доступна для просмотра через API как пользователю, так и администратору.

#### **III. Умная автоматизация рабочего процесса:**
-   **Автоматическая смена статуса:** При первом ответе администратора статус тикета автоматически меняется с `open` на `in_progress`, что упрощает отслеживание.
-   **Контекстная привязка сообщений:** В случаях, когда пользователь пишет новое сообщение без прямого ответа, оно привязывается к диалогу с самой последней активностью, а не просто к последнему созданному тикету.
</details>

<details>
<summary>📋 Реализация четвертого этапа, п. 4: Автоматизация реферального цикла</summary>

На этом этапе была реализована функция, замыкающая реферальный цикл и улучшающая пользовательский опыт. Теперь при регистрации нового пользователя (реферала) система может автоматически создать его карточку контакта в записной книжке пригласившего (реферера).

#### **I. Опциональное управление функцией:**

-   **Новая настройка:** В модель `Person` добавлено поле `auto_create_referral_contact` (по умолчанию `false`), позволяющее каждому пользователю индивидуально включать или отключать эту функцию.
-   **API для управления:** Реализованы эндпоинты `GET` и `PATCH /api/profile/auto-create-referral-contact-settings` для удобного управления настройкой со стороны фронтенда.

#### **II. Интеграция в процесс регистрации:**

-   **Централизованная логика:** Вся логика инкапсулирована в приватной функции `_create_contact_for_referrer` в `auth_service.py`.
-   **Переиспользование кода:** Функция не дублирует логику, а переиспользует существующий сервис `contact_service.create_contact` для создания контакта.
-   **Надежность:** Реализована обработка `HTTPException 409 Conflict`, которая предотвращает сбой, если у реферера уже существует контакт с такими данными, и делает процесс идемпотентным.

</details>

<details>
<summary>📋 Рефактонинг API</summary>

#### **I. Улучшения API и производительности:**

- **Стандартизация путей API:** Все эндпоинты для получения коллекций ресурсов (например, `/api/events/`) были приведены к единому стандарту без завершающего слеша (`/api/events`). Это устраняет ненужные редиректы и повышает надежность API.

#### **II. Расширение API управления папками:**

-   **Создание с наполнением:** Эндпоинт `POST /api/contact-folders` теперь принимает опциональный список `contact_ids`, позволяя создать папку и сразу же добавить в нее контакты за один запрос.
-   **Атомарное обновление:** Эндпоинт `PUT /api/contact-folders/{folder_id}` теперь позволяет одновременно изменять имя папки и/или полностью заменять список ее участников, передавая новый массив `contact_ids`. Это обеспечивает предсказуемость и упрощает логику на стороне клиента.
-   **Адаптация сервисного слоя:** Сервисы `create_contact_folder` и `update_contact_folder` были обновлены для поддержки расширенной логики.

#### **III. Рефакторинг API: Middleware для обработки URL:**

**Проблема:** `Cross-origin` запросы к эндпоинтам с завершающим слэшем (например, `/api/contacts/`) приводили к ошибке `401 Unauthorized`. Это было вызвано тем, что FastAPI по умолчанию отправлял ответ `307 Temporary Redirect` на URL без слэша, в процессе которого браузер терял заголовок `Authorization`.

**Решение:**
-   **Внедрен Middleware:** В `app/main.py` добавлен кастомный middleware, который выполняется перед обработкой каждого запроса.
-   **Нормализация пути:** Middleware проверяет путь запроса и, если он содержит завершающий слэш (и это не корневой путь), программно удаляет его из `request.scope["path"]` до того, как запрос будет передан в роутер.

**Результат:**
-   **Проблема решена:** Причина для редиректа устранена на уровне сервера. Заголовок `Authorization` больше не теряется.
-   **API стал более гибким:** Бэкенд теперь корректно обрабатывает запросы независимо от наличия завершающего слэша, что снижает вероятность ошибок на стороне клиента.
-   **Централизованный подход:** Проблема решена в одном месте для всего приложения, что является чистым и легко поддерживаемым решением.

</details>

<details>
<summary>📋 API endpoints and docstrings</summary>

---

<details>
<summary>➡️ 1. Аутентификация (`/api/auth`)</summary>

#### `POST /telegram`

**Summary:** Аутентификация через Telegram

**Description:**
Аутентифицирует пользователя через Telegram Mini App `initData` и управляет его жизненным циклом в системе.

**Ключевая логика "умной" аутентификации:**

1.  **Валидация `initData`:** Проверяется подлинность данных, полученных от Telegram.

2.  **Поиск или создание пользователя:**
    *   **Стандартный вход:** Если пользователь с таким `telegram_id` уже существует, его данные (`username`, `first_name` и т.д.) обновляются, и он успешно входит в систему.
    *   **Первый вход (Новый пользователь):** Если пользователь входит впервые, система создает для него:
        1.  Центральную сущность `Person`.
        2.  Профиль `TelegramAccount` с `is_verified=True`.
        3.  Персональную карточку контакта (`is_self=True`), которая представляет пользователя в его собственной телефонной книге.
    *   **Верификация "заглушки":** Если контакт с таким `telegram_id` уже был добавлен в систему другим пользователем (как "заглушка" с `is_verified=False`), при первом входе этого пользователя его аккаунт "оживает": данные обновляются, и он становится верифицированным пользователем.
    *   **"Протокол разрешения парадоксов":** Система корректно обрабатывает сценарии, когда `username` или `phone_number` переходят от одного `telegram_id` к другому, обеспечивая целостность данных.

3.  **Возврат JWT-токена:** В случае успеха возвращается `access_token` для доступа к защищенным эндпоинтам.

---
</details>

<details>
<summary>➡️ 2. Профиль и Безопасность (`/api/profile`)</summary>

#### `GET /`
**Summary:** Получение полного профиля текущего пользователя

**Description:**
Возвращает полный профиль текущего аутентифицированного пользователя, включая его личную карточку контакта (`self_contact_card`).

---

#### `POST /pincode/set`
**Summary:** Установка ПИН-кода

**Description:**
Устанавливает ПИН-код для текущего пользователя. Невозможно использовать, если ПИН-код уже установлен.

---

#### `POST /pincode/change`
**Summary:** Смена ПИН-кода

**Description:**
Изменяет ПИН-код пользователя. Требуется ввести старый и новый ПИН-коды.

---
</details>

<details>
<summary>➡️ 3. Контакты (`/api/contacts`)</summary>

#### `POST /`
**Summary:** Создание нового контакта

**Description:**
Создает новую, полностью укомплектованную карточку контакта для текущего пользователя.

Этот эндпоинт является основным способом добавления контактов и позволяет передать все данные, включая вложенные списки, за один запрос:
- **Основные поля:** `first_name`, `last_name`, `company_name`, `hobbies` и т.д.
- **Идентификаторы:** `telegram_id`, `username`.
- **Вложенные коллекции:**
    - `phones`: список телефонов.
    - `emails`: список email-адресов.
    - `social_media`: список ссылок на соцсети.
    - `addresses`: список структурированных адресов.

Система автоматически найдет или создаст связанный `TelegramAccount` на основе предоставленных идентификаторов.

---

#### `GET /`
**Summary:** Получение списка контактов

**Description:**
Возвращает список всех контактов, принадлежащих текущему Person.

---

#### `GET /{contact_id}`
**Summary:** Получение контакта по ID

**Description:**
Возвращает контакт по ID, если он принадлежит текущему Person.

---

#### `PATCH /{contact_id}`
**Summary:** Частичное обновление контакта

**Description:**
Обновляет **основные (скалярные) поля** карточки контакта, такие как `first_name`, `hobbies`, `company_name` и т.д.

**ВАЖНО:** Этот эндпоинт **не предназначен** для управления вложенными коллекциями (телефоны, email, адреса).
Для добавления, изменения или удаления элементов в этих коллекциях используйте специализированные эндпоинты:
- `POST /contacts/{contact_id}/labeled-items/{item_type}`
- `PATCH /contacts/{contact_id}/labeled-items/{item_id}`
- `DELETE /contacts/{contact_id}/labeled-items/{item_id}`
- и аналогичные для `/addresses`.

---

#### `DELETE /{contact_id}`
**Summary:** Удаление контакта

**Description:**
Удаляет контакт по ID, если он принадлежит текущему Person.

---

#### `POST /bulk-delete`
**Summary:** Массовое удаление контактов

**Description:**
Удаляет несколько контактов по списку их ID.
Не позволяет удалить собственную карточку контакта.

---

#### `GET /unverified`
**Summary:** Получение списка неавторизованных контактов

**Description:**
Возвращает список всех контактов, которые еще не авторизованы в системе (не являются пользователями PrimeNetworking).

---

#### `GET /{contact_id}/shared-contacts`
**Summary:** Получение общих контактов

**Description:**
Возвращает список общих контактов между текущим пользователем и указанным контактом.
Работает только если указанный контакт также является пользователем сервиса.

---

#### `POST /{contact_id}/addresses`
**Summary:** Добавление нового адреса

**Description:**
Создает новый структурированный адрес для указанного контакта.

---

#### `PATCH /{contact_id}/addresses/{address_id}`
**Summary:** Обновление адреса

**Description:**
Частично обновляет один конкретный адрес в коллекции адресов контакта.
Это предпочтительный способ для точечного изменения данных адреса.

---

#### `DELETE /{contact_id}/addresses/{address_id}`
**Summary:** Удаление адреса

**Description:**
Удаляет существующий адрес по его ID.

---

#### `POST /{contact_id}/relations`
**Summary:** Создание новой связи между контактами (близкий)

**Description:**
Создает новую типизированную связь от текущего контакта (`contact_id`) к другому контакту (`related_contact_id`).

- **`related_contact_id`**: ID контакта из вашей записной книжки, на который вы хотите сослаться.
- **`label_name`**: Тип связи, например "Жена", "Партнер", "Коллега".

**Стандартные этикетки для связей:**
- `Муж`, `Жена`, `Отец`, `Мать`, `Брат`, `Сестра`, `Сын`, `Дочь`, `Партнер`, `Коллега`, `Друг`, `Подруга`

Если метка с таким названием не существует, будет создана кастомная автоматически.

---

#### `DELETE /{contact_id}/relations/{relation_id}`
**Summary:** Удаление связи между контактами

**Description:**
Удаляет существующую типизированную связь по её ID.

---

#### `POST /{contact_id}/labeled-items/{item_type}`
**Summary:** Добавление нового поля с этикеткой (телефон, email, соцсеть)

**Description:**
Создает новый элемент (телефон, email, соцсеть) для указанного контакта.
Тип элемента передается в URL (`phone`, `email`, `social_media`).

---

#### `PATCH /{contact_id}/labeled-items/{item_id}`
**Summary:** Обновление поля с этикеткой (телефон, email, соцсеть)

**Description:**
Частично обновляет один конкретный элемент в коллекции (телефон, email, соцсеть).
Это предпочтительный способ для точечного изменения данных.

---

#### `DELETE /{contact_id}/labeled-items/{item_id}`
**Summary:** Удаление поля с этикеткой (телефон, email, соцсеть)

**Description:**
Удаляет существующий элемент (телефон, email, соцсеть) по его ID.

---

#### `POST /{contact_id}/custom_field_values`
**Summary:** Добавление значения кастомного поля

**Description:**
Добавляет новое значение пользовательского поля для конкретного контакта.

---

#### `PATCH /{contact_id}/custom_field_values/{value_id}`
**Summary:** Обновление значения кастомного поля

**Description:**
Частично обновляет существующее значение пользовательского поля для контакта.

---

#### `DELETE /{contact_id}/custom_field_values/{value_id}`
**Summary:** Удаление значения кастомного поля

**Description:**
Удаляет значение пользовательского поля для контакта.

---
</details>

<details>
<summary>➡️ 4. Пользовательские Поля (`/api/custom-fields`)</summary>

#### `POST /`
**Summary:** Создание определения кастомного поля

**Description:**
Создает новое определение кастомного поля для текущего Person. Это "шаблон" поля, который затем можно будет использовать для всех контактов.

---

#### `GET /`
**Summary:** Получение списка определений кастомных полей

**Description:**
Возвращает список всех определений кастомных полей, созданных текущим Person.

---

#### `DELETE /{field_id}`
**Summary:** Удаление определения кастомного поля

**Description:**
Удаляет определение кастомного поля. ВНИМАНИЕ: Это также удалит все значения этого поля у всех контактов (каскадное удаление).

---
</details>

<details>
<summary>➡️ 5. Этикетки (`/api/labels`)</summary>

#### `GET /`
**Summary:** Получение списка этикеток по типу

**Description:**
Возвращает список всех доступных этикеток для текущего пользователя для указанного типа. Включает стандартные (глобальные) и кастомные этикетки пользователя. Используется для заполнения выпадающих списков на фронтенде.

---

#### `POST /`
**Summary:** Создание новой кастомной этикетки

**Description:**
Позволяет пользователю явно создать свою собственную этикетку. Система проверяет, что пользователь не создает дубликат существующей стандартной или своей кастомной этикетки.

---

#### `DELETE /{label_id}`
**Summary:** Удаление кастомной этикетки

**Description:**
Удаляет кастомную этикетку пользователя.
- Нельзя удалить стандартную (глобальную) этикетку.
- Нельзя удалить этикетку, если она в данный момент используется хотя бы в одном контакте.

---

</details>

<details>
<summary>➡️ 6. Папки для Контактов (`/api/contact-folders`)</summary>

#### `POST /`
**Summary:** Создание новой папки для контактов

**Description:**
Создает новую папку для группировки контактов.

- **name**: Название папки (обязательно).
- **contact_ids**: Опциональный список ID контактов, которые будут добавлены в папку сразу после ее создания.

---

#### `GET /`
**Summary:** Получение списка всех папок

**Description:**
Возвращает список всех папок, созданных текущим пользователем.

---

#### `GET /{folder_id}/contacts`
**Summary:** Получение списка контактов в папке

**Description:**
Возвращает список всех контактов, находящихся в указанной папке по ее ID.

---

#### `PUT /{folder_id}`
**Summary:** Обновление папки (имя и/или состав)

**Description:**
Обновляет папку. Можно изменить имя и/или полностью заменить список контактов.

- **name**: Новое название папки.
- **contact_ids**: Полный новый список ID контактов.
Предыдущий список будет полностью заменен.
Передача пустого списка `[]` очистит папку.

---

#### `DELETE /{folder_id}`
**Summary:** Удаление папки

**Description:**
Удаляет папку по ее ID.
Все связи этой папки с контактами будут также удалены.

---

#### `POST /{folder_id}/contacts/bulk-add`
**Summary:** Массовое добавление контактов в папку

**Description:**
Добавляет несколько контактов в папку за один запрос.
Игнорирует контакты, которые уже есть в папке.

---

#### `POST /{folder_id}/contacts/bulk-remove`
**Summary:** Массовое удаление контактов из папки

**Description:**
Удаляет несколько контактов из папки за один запрос.

---

#### `POST /{folder_id}/contacts/{contact_id}`
**Summary:** Добавление контакта в папку

**Description:**
Добавляет существующий контакт в существующую папку.
Оба объекта должны принадлежать текущему пользователю.

---

#### `DELETE /{folder_id}/contacts/{contact_id}`
**Summary:** Удаление контакта из папки

**Description:**
Удаляет связь между контактом и папкой.
Сами объекты при этом не удаляются.

---
</details>

<details>
<summary>➡️ 7. AI Парсинг - обогащение данными карточек контактов (`/api/contacts`)</summary>

#### `POST /{contact_id}/parse-social-media`
**Summary:** [DEPRECATED] Запуск AI-парсинга по прямой ссылке

**Description:**
**Устаревший эндпоинт.** Запускает фоновую задачу для сбора и анализа информации по URL, переданному в теле запроса.

Рекомендуется использовать новый эндпоинт `POST /{contact_id}/labeled-items/{item_id}/parse`, который работает с уже сохраненной в контакте ссылкой.

---

#### `POST /{contact_id}/labeled-items/{item_id}/parse`
**Summary:** Запуск AI-парсинга для сохраненной ссылки

**Description:**
**Основной эндпоинт для запуска AI-анализа.**

Запускает фоновую задачу для сбора и анализа информации по URL, который хранится в указанном `labeled-item` (типа 'social_media').

**Процесс работы:**
1.  **Сбор данных:** Playwright и BeautifulSoup собирают текстовый контент и URL изображений с веб-страницы.
2.  **AI-анализ:** Текст и изображения анализируются с помощью Mistral AI для извлечения структурированных данных (интересы, навыки, личные качества и т.д.).
3.  **Сохранение:** Результат анализа сохраняется в базу данных как `ParsingSuggestion` со статусом `pending`, а затем `completed` или `failed`.

---

#### `GET /{contact_id}/suggestions/latest/preview`
**Summary:** Предпросмотр последнего результата AI-парсинга

**Description:**
**"Сухой прогон" (dry run) для последнего AI-предложения.**

Автоматически находит последний завершенный результат AI-парсинга для контакта и возвращает, как будет выглядеть карточка контакта **после** его применения.
Изменения в базу данных не сохраняются.

---

#### `POST /{contact_id}/suggestions/latest/confirm`
**Summary:** Подтверждение последнего результата AI-парсинга

**Description:**
**Финальный шаг: применение последнего AI-предложения.**

Автоматически подтверждает последний результат AI-парсинга, объединяет предложенные данные с существующими данными в карточке контакта и сохраняет результат в базу данных.

---

#### `GET /{contact_id}/suggestions/{suggestion_id}/preview`
**Summary:** Предпросмотр выбранного результата AI-парсинга

**Description:**
**"Сухой прогон" (dry run) для конкретного AI-предложения из истории.**

Возвращает, как будет выглядеть контакт после подтверждения указанного результата AI-парсинга (`suggestion_id`).
Изменения в базу данных не сохраняются.

---

#### `POST /{contact_id}/suggestions/{suggestion_id}/confirm`
**Summary:** Подтверждение выбранного результата AI-парсинга

**Description:**
**Финальный шаг: применение выбранного AI-предложения из истории.**

Подтверждает указанный результат AI-парсинга (`suggestion_id`), объединяет предложенные данные с существующими и сохраняет результат в базу данных.

---

#### `GET /{contact_id}/suggestions/previews`
**Summary:** Получение списка всех предпросмотров

**Description:**
Возвращает список всех готовых предложений для контакта в виде предпросмотров.
Каждый элемент списка - это уже объединенный результат текстового и визуального анализа, примененный к текущему состоянию контакта.
Полезно для отображения истории парсинга на фронтенде.

---

#### `GET /{contact_id}/suggestions`
**Summary:** [DEBUG] Получение 'сырых' результатов AI-парсинга

**Description:**
Отладочный эндпоинт. Возвращает список всех 'сырых' AI-предложений для указанного контакта без объединения текстового и визуального анализа.

---
</details>

<details>
<summary>➡️ 8. Персонализированные рекомендации от AI (`/api/ai`)</summary>

#### `POST /recommendation`
**Summary:** Генерация AI рекомендации для поля контакта

**Description:**
Генерирует контекстную идею для начала разговора на основе данных из карточки контакта.

- **`contact_id`**: ID контакта, для которого генерируется рекомендация.
- **`field_name`**: Название поля, на основе которого генерируется рекомендация (напр., 'hobbies').
- **`field_value`**: Полное текстовое значение поля из карточки контакта.
- **`current_index`**: Индекс значения внутри `field_value` для генерации (если их несколько, разделенных запятой).
- **`previous_recommendations`**: Список предыдущих рекомендаций для обеспечения уникальности нового ответа.

---
</details>


<details>
<summary>➡️ 9. События и Уведомления (`/api/events`)</summary>

#### `POST /`
**Summary:** Создание нового события

**Description:**
Создает новое событие, связывает его с участниками и делегирует планирование уведомлений.

- **`title`**: Название события (обязательно).
- **`start_datetime`**, **`end_datetime`**: Дата и время начала и окончания события.
- **`contact_ids`**: Опциональный список ID контактов-участников.
- **`frequency`**: Частота повторения (`once`, `daily`, `weekly`, `monthly`, `yearly`).
- **`is_active`**: Флаг, отвечающий за создание уведомлений.

---

#### `GET /`
**Summary:** Получение списка событий пользователя

**Description:**
Возвращает список событий для текущего пользователя с возможностью фильтрации.

- **`start_date`**, **`end_date`**: Фильтрация по диапазону дат.
- **`contact_id`**: Фильтрация по ID контакта-участника.

---

#### `GET /{event_id}`
**Summary:** Получение события по ID

**Description:**
Возвращает полную информацию о конкретном событии по его ID.

---

#### `PATCH /{event_id}`
**Summary:** Обновление события

**Description:**
Частично обновляет существующее событие. Можно изменить любые параметры, включая название, даты, участников и настройки уведомлений.

---

#### `DELETE /{event_id}`
**Summary:** Удаление события

**Description:**
Удаляет событие по его ID. Все связанные запланированные уведомления также будут удалены.

---

#### `POST /bulk-delete`
**Summary:** Массовое удаление событий

**Description:**
Удаляет несколько событий по списку их ID за один запрос.

---
</details>

<details>
<summary>➡️ 10. Подписки (`/api/subscriptions`)</summary>

#### `POST /confirm-change`
**Summary:** Подтвердить и выполнить смену/покупку подписки

**Description:**
**Финальный шаг: подтверждение и инициация оплаты.**

Этот эндпоинт выполняет действие, предварительно рассчитанное одним из эндпоинтов `/calculate-upgrade` или `/calculate-with-bonus`.
Он является "исполнителем" и вносит изменения в базу данных.

**Сценарии использования:**

1.  **Покупка с оплатой (новая, продление, апгрейд с доплатой):**
    - Клиент передает `tier_name`, `payment_period_months` и опционально `points_to_use`.
    - Сервис пересчитывает итоговую стоимость с учетом кредита и бонусов.
    - Создается запись `Payment` в статусе `pending`.
    - Генерируется и возвращается СБП QR-код для оплаты.
    - **Результат:** `status: "payment_required"`.

2.  **Бесплатный апгрейд (за счет кредита):**
    - Клиент передает `tier_name` и `payment_period_months`.
    - Сервис определяет, что кредита за неиспользованное время достаточно для полного покрытия стоимости.
    - Подписка пользователя обновляется **мгновенно**.
    - Создается "виртуальный" платеж со статусом `succeeded` для истории.
    - **Результат:** `status: "activated"`, QR-код не возвращается.

**Важно:** Перед вызовом этого эндпоинта рекомендуется всегда вызывать один из эндпоинтов расчета, чтобы показать пользователю итоговую стоимость и получить его подтверждение.

---

#### `POST /calculate-upgrade`
**Summary:** Рассчитать стоимость апгрейда/продления (без бонусов)

**Description:**
**Основной эндпоинт для расчета стоимости подписки без учета бонусных баллов.**

Выполняет "сухой прогон" (dry run) для всех сценариев:
- **Новая покупка:** для пользователей с тарифом 'free'.
- **Продление:** для пользователей, продлевающих текущий тариф.
- **Апгрейд:** для пользователей, переходящих на более высокий тариф. При этом рассчитывается и применяется кредит за неиспользованное время текущей подписки.

Этот эндпоинт следует вызывать первым, чтобы показать пользователю базовую стоимость
и возможный кредит перед тем, как предлагать использовать бонусы.

Не вносит никаких изменений в базу данных.
Возвращает детальный расчет для отображения пользователю перед подтверждением.

---

#### `POST /calculate-with-bonus`
**Summary:** Рассчитать итоговую стоимость с учетом бонусов

**Description:**
**Второй шаг расчета: применение бонусных баллов.**

Выполняет "сухой прогон" для расчета итоговой стоимости подписки с учетом списания бонусов.
Этот эндпоинт следует вызывать, когда пользователь вводит количество бонусов, которое хочет потратить.

- **points_to_use**: Количество бонусов, которое пользователь хочет применить.

Возвращает итоговую сумму к оплате, фактически использованное количество бонусов и остаток на бонусном счете.

---

#### `GET /status`
**Summary:** Получить статус подписки текущего пользователя

**Description:**
Возвращает информацию о текущей подписке пользователя:
- Роль
- Название тарифа
- Дату окончания
- Флаг активности

---

#### `GET /tiers`
**Summary:** Получить список активных тарифных планов

**Description:**
Возвращает список всех тарифных планов, которые активны и доступны для покупки.

---
</details>

<details>
<summary>➡️ 11. Бонусная и реферальная система (`/api/bonus_system`)</summary>

#### `POST /generate-link`
**Summary:** Генерация реферальной ссылки пользователя

**Description:**
Генерирует и возвращает персональную реферальную ссылку для текущего пользователя.

---

#### `GET /my-stats`
**Summary:** Получить статистику реферальной сети

**Description:**
Возвращает статистику по реферальной программе для текущего пользователя:
- Количество рефералов 1-го и 2-го уровней.
- Общая сумма заработанных бонусов.
- Текущий баланс бонусов.

---

#### `GET /my-network`
**Summary:** Получить реферальную сеть пользователя

**Description:**
Возвращает полную структуру реферальной сети пользователя:
- Кто его пригласил (inviter).
- Кого он пригласил (referrals_level_1).
- Кого пригласили его рефералы (referrals_level_2).

---

#### `GET /history`
**Summary:** Получить историю движения бонусов пользователя

**Description:**
Возвращает историю начислений и списаний бонусных баллов для текущего пользователя с пагинацией.

---
</details>

<details>
<summary>➡️ 12. Обратная связь и Поддержка (`/api/support`)</summary>

#### `POST /tickets`
**Summary:** Создать новое обращение в поддержку

**Description:**
Создает новое обращение в службу поддержки от аутентифицированного пользователя.
После создания тикета система автоматически уведомляет администраторов.

**Логика работы системы поддержки:**

1.  **Создание тикета:**
    *   Пользователь отправляет запрос на этот эндпоинт с `subject` (опционально) и `message`.
    *   Система создает запись `SupportTicket` со статусом `open` и `priority` `medium`.
    *   Администраторы получают уведомление в Telegram-чат поддержки (или индивидуально), содержащее детали тикета и ссылку на пользователя.

2.  **Ответ администратора:**
    *   Администратор может ответить на тикет **двумя способами**:
        *   **Быстрый ответ (вне системы):** Нажать на кнопку "Открыть профиль пользователя" в уведомлении и написать пользователю напрямую в Telegram. Эта переписка **не логируется** в системе поддержки.
        *   **Официальный ответ (через систему):** В чате поддержки Telegram администратор нажимает "Ответить" (Reply) на уведомление о тикете (которое содержит `#ticket-ID`) и пишет свой ответ.
            *   Система перехватывает этот ответ через вебхук Telegram.
            *   Сообщение администратора сохраняется в `SupportMessage` и привязывается к соответствующему тикету.
            *   Статус тикета автоматически меняется на `in_progress` при первом ответе администратора.
            *   Сообщение пересылается пользователю в личные сообщения от имени бота с префиксом `[Тикет #ID]`.

3.  **Ответ пользователя:**
    *   Пользователь может ответить на сообщение бота в личных сообщениях.
    *   Система перехватывает ответ пользователя через вебхук Telegram.
    *   **Привязка сообщения:**
        *   Если пользователь отвечает на сообщение бота, содержащее `[Тикет #ID]`, его ответ автоматически привязывается к этому тикету.
        *   Если пользователь пишет новое сообщение без прямого ответа, система ищет тикет с **последней активностью** (по `updated_at`) от этого пользователя и привязывает сообщение к нему.
    *   Сообщение пользователя сохраняется в `SupportMessage`.
    *   Сообщение пересылается в чат поддержки администраторов с указанием, от кого оно и к какому тикету относится.

**Таким образом, вся официальная переписка по тикету сохраняется в базе данных и доступна через API.**

---

#### `GET /tickets/{ticket_id}/messages`
**Summary:** Получить переписку по своему обращению

**Description:**
Возвращает историю переписки по обращению из `SupportMessage`, если текущий пользователь является его автором.

---
</details>

<details>
<summary>➡️ 13. Администрирование (`/api/admin`)</summary>

#### `GET /persons`
**Summary:** Получить список всех пользователей

**Description:**
Возвращает постраничный список всех пользователей системы.
Позволяет фильтровать пользователей по их роли (`free`, `base`, `vip`, `admin`).
Ответ содержит основную информацию о пользователе и его Telegram-аккаунте.
**Доступно только для администраторов.**

---

#### `GET /persons/{person_id}`
**Summary:** Получить детальную информацию о пользователе

**Description:**
Возвращает полную информацию о конкретном пользователе, включая его личную карточку контакта,
данные о подписке, а также статистику и структуру его реферальной сети.
**Доступно только для администраторов.**

---

#### `PATCH /persons/{person_id}`
**Summary:** ⚠Обновить данные подписки пользователя⚠

**Description:**
**ВНИМАНИЕ:** Это действие напрямую влияет на доступ пользователя к функциям и его статус подписки.

Обновляет роль и/или дату окончания подписки для указанного пользователя.
При изменении роли на платную (`base`, `vip`), система автоматически привязывает пользователя к соответствующему тарифу.
При сбросе на `free` — очищает все данные о подписке.

Отправляйте только те поля, которые хотите изменить.
**Доступно только для администраторов.**

---

#### `GET /persons/{person_id}/subscription-history`
**Summary:** Получить историю подписки пользователя

**Description:**
Возвращает полный, неизменяемый журнал всех событий, связанных с подпиской пользователя (активация, истечение, ручное изменение).
Записи отсортированы от новых к старым.
**Доступно только для администраторов.**

---

#### `GET /payments`
**Summary:** Получить список всех платежей

**Description:**
Возвращает список всех платежей в системе с пагинацией.
Позволяет фильтровать по статусу (`pending`, `succeeded`, `failed`, `canceled`), ID пользователя, а также по диапазону дат создания.
**Доступно только для администраторов.**

---

#### `GET /payments/{payment_id}`
**Summary:** Получить детали конкретного платежа

**Description:**
Возвращает полную информацию о конкретном платеже, включая сгенерированный QR-код и метаданные.
**Доступно только для администраторов.**

---

#### `POST /payments/{payment_id}/check-status`
**Summary:** Ручная проверка статуса платежа

**Description:**
Принудительно инициирует проверку статуса конкретного платежа через API Банка Точка.
Полезно, если автоматическая проверка или вебхук не сработали.
**Доступно только для администраторов.**

---

#### `POST /payments/{payment_id}/force-activate`
**Summary:** ⚠Принудительная активация оплаты подписки⚠

**Description:**
Принудительно активирует подписку для пользователя, связанного с этим платежом,
независимо от его статуса. **Обходит логику проверки статуса в банке.**
**ВНИМАНИЕ:** Используется для тестирования и ручного разрешения проблемных ситуаций.
**Доступно только для администраторов.**

---

#### `GET /subscription-tiers`
**Summary:** Получить список всех тарифных планов

**Description:**
Возвращает список всех тарифных планов, существующих в системе, включая неактивные.
**Доступно только для администраторов.**

---

#### `POST /subscription-tiers`
**Summary:** ⚠Создать новый тарифный план⚠

**Description:**
**ВНИМАНИЕ:** Создание нового тарифа требует последующей настройки на стороне фронтенда.
Создает новый тарифный план в системе. Имя тарифа должно быть уникальным.
**Доступно только для администраторов.**

---

#### `PATCH /subscription-tiers/{tier_id}`
**Summary:** ⚠Обновить существующий тарифный план⚠

**Description:**
**ВНИМАНИЕ:** Изменение цен или статуса `is_active` напрямую повлияет на возможность покупки тарифа пользователями.
Обновляет данные существующего тарифного плана (например, цены или описание).
Отправляйте только те поля, которые хотите изменить.
**Доступно только для администраторов.**

---

#### `GET /support-tickets`
**Summary:** Получить список всех обращений в поддержку

**Description:**
Возвращает список всех обращений в поддержку с пагинацией, отсортированных по дате обновления.
**Доступно только для администраторов.**

---

#### `GET /support-tickets/{ticket_id}`
**Summary:** Получить полную информацию по ID тикета

**Description:**
Возвращает полную информацию о конкретном обращении в поддержку, включая все связанные с ним сообщения.
**Доступно только для администраторов.**

---

#### `PATCH /support-tickets/{ticket_id}`
**Summary:** ⚠Обновить параметры тикета по ID⚠

**Description:**
**ВНИМАНИЕ:** Изменение статуса или назначение ответственного влияет на рабочий процесс поддержки.
Обновляет данные обращения в поддержку. Доступно только для администраторов.

**Допустимые значения:**
- **status**: `open`, `in_progress`, `resolved`, `closed`
- **priority**: `low`, `medium`, `high`
- **assigned_to_admin_id**: внутренний ID пользователя-администратора (person.id).
**Доступно только для администраторов.**

---

#### `GET /support-tickets/{ticket_id}/messages`
**Summary:** Получить переписку по ID тикета

**Description:**
Возвращает всю историю переписки (сообщения от пользователя и администраторов) для конкретного обращения в поддержку.
**Доступно только для администраторов.**

---
</details>

<details>
<summary>➡️ 14. Внутренние Задачи (Cron) (`/api/tasks`)</summary>

#### `POST /process-notifications`
**Summary:** Запуск обработки и отправки уведомлений

**Description:**
Этот эндпоинт предназначен для вызова внешним cron-сервисом.
Он запускает синхронную обработку всех событий, у которых подошел срок.
**Защищен секретным ключом `X-Cron-Secret`.**

---

#### `POST /check-pending-subscriptions`
**Summary:** Запуск проверки ожидающих платежей по подпискам

**Description:**
Этот эндпоинт предназначен для вызова внешним cron-сервисом.
Он запускает асинхронную проверку всех платежей со статусом 'pending'.
**Защищен секретным ключом `X-Cron-Secret`.**

---

#### `POST /check-expire-subscriptions`
**Summary:** Запуск проверки и деактивации истекших подписок

**Description:**
Этот эндпоинт предназначен для вызова внешним cron-сервисом (например, раз в сутки).
Он находит всех пользователей с истекшей датой подписки и сбрасывает их роль на 'free'.
**Защищен секретным ключом `X-Cron-Secret`.**

---

#### `POST /process-daily-bonuses`
**Summary:** Запуск обработки ежедневных бонусов за активность

**Description:**
Этот эндпоинт предназначен для вызова внешним cron-сервисом.
Он запускает расчет ежедневных бонусов за активность для всех пользователей.
**Защищен секретным ключом `X-Cron-Secret`.**

---

#### `POST /cleanup-notifications`
**Summary:** Запуск очистки старых записей уведомлений

**Description:**
Этот эндпоинт предназначен для вызова внешним cron-сервисом (например, раз в сутки).
Он удаляет старые (старше 90 дней) записи об уведомлениях со статусом 'sent' или 'failed'
для предотвращения разрастания таблицы.
**Защищен секретным ключом `X-Cron-Secret`.**

---
</details>

<details>
<summary>➡️ 15. Внешние Задачи (Webhooks) (`/api/webhooks`)</summary>

#### `POST /tochka/payment-status`
**Summary:** Обработка вебхука от Банка Точка о статусе платежа

**Description:**
Принимает и обрабатывает входящие вебхуки от Банка Точка.
Подлинность запроса проверяется через JWT подпись в зависимости `verify_tochka_webhook`.

---

#### `POST /telegram`
**Summary:** Обработка вебхука от Telegram

**Description:**
Принимает входящие обновления от Telegram (сообщения, колбэки и т.д.).
Этот эндпоинт не требует аутентификации, так как Telegram не передает токены.

</details>

</details>

---

## 📅 Общий план разработки для ver. 1.0.0 (updated 22.09)
  
  🛠️ **Прогресс разработки MVP** 🛠️  
  `[█████████████████████] 100%`

### Приоритет 1: Основная база

- [x] **Телефонная книга и добавление контактов**
  - [x] Разработана умная масштабируемая логика для реализации широкого спектра фич сервиса.
  - [x] Продвинутый CRUD для пользователей (учет верификации и активности, логические связи).
  - [x] Продвинутый CRUD для контактов (создание персонализированных карточек и операции с ними).
  - [x] Механизм получения списка общих контактов, списка неверифицированных контактов.
  - [x] Определение и присвоение значений кастомных полей для контактов.

- [x] **Исследование / прототипирование: Интеграция AI для парсинга информации с соцсетей**
  - [x] Определение необходимых данных для парсинга (интересы, музыкальные вкусы и т.д.).
  - [x] Выбор технологий (библиотеки, фреймворки для NLP и веб-скрапинга).
  - [x] Модуль AI для сбора данных о контакте при вводе ссылки, в т.ч. с динамических сайтов.
  - [x] Механизм умного слияния и дополнения данных из текстового и визуального парсеров.
  - [x] Преобразование данных в структурированный объект для демонстрации пользователю.
  - [x] Механизм подтверждения и сохранения пользователем подтянутой информации.

### Приоритет 2: Расширение контактной книги и базовый AI-функционал

- [x] **Отслеживание событий, планирование и уведомления**
  - [x] Возможность добавлять события к контактам с поддержкой повторений.
  - [x] Система уведомлений через Telegram-бота о предстоящих событиях.

- [x] **Персонализированные рекомендации от AI**
  - [x] Рекомендации при просмотре карточки контакта на основе пролистанных полей.
  - [x] Рекомендации в контексте событий (например, «Что подарить на день рождения?»).  

*Зависит от успешного прототипирования AI-парсинга и наличия достаточного объёма данных.

### Приоритет 3: Монетизация и геймификация
- [x] **Внедрение монетизации**
  - [x] Система оплаты подписки
  - [x] Система бонусов за активности
  - [x] Реферальная двухуровневая система + реф. ссылка для приглашения

### Приоритет 4: Настройки и поддержка

- [x] **Настройки: уведомления, PIN-код, обратная связь**
  - [x] Гибкое управление типами уведомлений
  - [x] Опция автосоздания контакта реферера для реферала
  - [x] Опция автосоздания контакта реферала у реферера
  - [x] Защита аккаунта PIN-кодом.
  - [x] Полная интеграция функционала обратной связи support в telegram: чат поддержки, маркировка тикетов, сохранение истории и статусов обращений.

---

**Автор:** [mynamemyway](https://github.com/mynamemyway)