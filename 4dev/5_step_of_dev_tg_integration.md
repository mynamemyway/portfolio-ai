# Шаг 5: Интеграция с Telegram (aiogram)

**Цель:** Интегрировать созданную RAG-цепочку в Telegram-бота, обеспечив прием сообщений, генерацию ответов и сохранение истории диалога.

---

### 1. Модификация `main.py` для интеграции обработчиков

#### **1.1. Импорт необходимых модулей**
*   **Цель:** Подключить все компоненты, необходимые для работы бота.
*   **Файл:** `main.py`.
*   **Логика:**
    *   Импортировать `F` и `Router` из `aiogram`.
    *   Импортировать `CommandStart` и `Message` из `aiogram.types`.
    *   Импортировать `HumanMessage` и `AIMessage` из `langchain_core.messages`.
    *   Импортировать `get_rag_chain` из `app.core.chain`.
    *   Импортировать `get_chat_memory` из `app.core.memory`.

#### **1.2. Реализация обработчика команды `/start`**
*   **Цель:** Создать функцию, которая будет отправлять приветственное сообщение при старте диалога.
*   **Файл:** `main.py`.
*   **Логика:**
    *   Создать асинхронную функцию `handle_start(message: Message)`.
    *   Внутри функции определить текст приветствия, который объясняет роль бота.
    *   Отправить текст пользователю с помощью `await message.answer(...)`.

#### **1.3. Реализация основного обработчика текстовых сообщений**
*   **Цель:** Создать основной обработчик, который будет принимать текстовые сообщения, вызывать RAG-цепочку и управлять историей диалога.
*   **Файл:** `main.py`.
*   **Логика:**
    *   Создать асинхронную функцию `handle_message(message: Message)`.
    *   Определить `session_id` на основе `message.chat.id` для уникализации истории каждого пользователя.
    *   Получить экземпляр RAG-цепочки, вызвав `get_rag_chain()`.
    *   Вызвать цепочку асинхронно (`rag_chain.ainvoke`), передав `session_id` и текст сообщения (`message.text`).
    *   Отправить полученный от цепочки ответ пользователю (`await message.answer(ai_response)`).
    *   Получить экземпляр памяти `get_chat_memory(session_id)`.
    *   Сохранить в память вопрос пользователя и ответ AI с помощью `memory.save_context()`. Это критически важный шаг для поддержания контекста диалога.

#### **1.4. Настройка маршрутизатора (Router) и диспетчера (Dispatcher)**
*   **Цель:** Зарегистрировать созданные обработчики для их активации при получении соответствующих событий от Telegram.
*   **Файл:** `main.py`.
*   **Логика:**
    *   Создать экземпляр `Router`.
    *   Зарегистрировать обработчик `handle_start` для команды `/start` с помощью декоратора `@router.message(CommandStart())`.
    *   Зарегистрировать обработчик `handle_message` для всех текстовых сообщений с помощью декоратора `@router.message(F.text)`.
    *   В функции `main()` подключить роутер к диспетчеру: `dp.include_router(router)`.

#### **1.5. Добавление "индикатора печати"**
*   **Цель:** Улучшить пользовательский опыт, показывая, что бот обрабатывает запрос.
*   **Файл:** `main.py`.
*   **Логика:**
    *   Внутри `handle_message` перед вызовом RAG-цепочки добавить отправку действия "печатает" (`await bot.send_chat_action(chat_id=message.chat.id, action="typing")`).
    *   Это даст пользователю визуальную обратную связь о том, что его запрос принят в работу.

---

**Итог:** После выполнения всех пунктов этого плана файл `main.py` будет содержать полностью функционирующую логику Telegram-бота, способного вести осмысленный диалог на основе базы знаний и поддерживать контекст беседы с каждым пользователем индивидуально.