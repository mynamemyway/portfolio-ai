# Журнал разработки проекта "Portfolio-AI"

**Версия:** v0.3.0 (MVP)

Этот документ содержит хронологическое описание всех этапов разработки, принятых архитектурных решений и результатов тестирования для MVP (Minimum Viable Product) AI-ассистента.

---

## Шаг 1: Архитектура и настройка проекта

### 1.1. Структура Проекта и Контроль Версий

**Цель:** Создать логическую структуру папок для разделения кода, конфигурации и данных, а также настроить систему контроля версий.

**Действия:**
1.  **Создана структура директорий:**
    ```text
    Portfolio-AI/
    ├── app/
    │   ├── core/             # Ключевая бизнес-логика
    │   │   ├── config.py     # Управление конфигурацией
    │   │   ├── memory.py     # Модуль памяти
    │   │   ├── chain.py      # Логика RAG-цепочки
    │   │   └── rag.py        # Логика индексации базы знаний
    │   ├── knowledge_base/   # Исходные документы (.md)
    │   └── main.py           # Точка входа для Telegram-бота
    ├── chroma_db/            # Локальное хранилище векторов
    ├── .env                  # Файл с секретами
    ├── .gitignore
    ├── README.md
    └── requirements.txt
    ```
2.  **Инициализирован Git и `.gitignore`:** Настроен контроль версий и исключены из отслеживания чувствительные данные, виртуальное окружение и локальные базы данных.

### 1.2. Управление Зависимостями и Конфигурацией

**Цель:** Изолировать зависимости проекта и обеспечить безопасную работу с API-ключами.

**Действия:**
1.  **Настроено виртуальное окружение:** Создано окружение `venv` и файл `requirements.txt` для управления зависимостями.
2.  **Реализована безопасная конфигурация:** В `app/core/config.py` создан класс `Settings` на основе `pydantic-settings` для загрузки секретных ключей из `.env`, что исключает их жесткое кодирование в коде.

---

## Шаг 2: Реализация RAG - База знаний

### 2.1. Конфигурация и Инициализация Компонентов

**Цель:** Подготовить все строительные блоки для системы индексации в файле `app/core/rag.py`.

**Действия:**
1.  **Определены константы:** Централизованы пути к `KNOWLEDGE_BASE_DIR` и `CHROMA_PERSIST_DIR`.
2.  **Инициализирована модель эмбеддингов:** Создана фабричная функция `get_embedding_model()`, которая возвращает клиент для векторизации текста.
3.  **Инициализирована векторная БД:** Создана фабричная функция `get_vector_store()`, которая возвращает экземпляр `Chroma`, связанный с функцией векторизации и персистентной директорией.

### 2.2. Реализация Логики Индексации

**Цель:** Реализовать основной процесс, который загружает документы, разбивает их на чанки и сохраняет векторы в ChromaDB.

**Действия:**
1.  **Реализована функция `_load_and_split_documents()`:** Загружает все `.md` файлы из `knowledge_base`, используя `TextLoader`, и разбивает их на чанки с помощью `RecursiveCharacterTextSplitter`.
2.  **Реализована основная функция `create_vector_store()`:** Оркестрирует весь процесс — вызывает загрузку и сплиттинг, а затем добавляет полученные чанки в `ChromaDB` с помощью `vector_store.aadd_documents()`.
3.  **Создана точка входа:** Добавлен блок `if __name__ == "__main__":` для запуска индексации как отдельного скрипта (`python -m app.core.rag`).

---

## Шаг 3: Реализация RAG - Модуль памяти

### 3.1. Слой Данных — Взаимодействие с SQLite

**Цель:** Создать низкоуровневый компонент для асинхронной работы с базой данных для хранения истории чатов в файле `app/core/memory.py`.

**Действия:**
1.  **Реализован класс `SQLiteChatMessageHistory`:**
    - Наследуется от `langchain_core.chat_history.BaseChatMessageHistory`.
    - В `__init__` принимает `session_id` и асинхронно создает таблицу `chat_history(session_id TEXT, message TEXT)`, если она не существует.
    - Реализовано асинхронное свойство `messages` для `SELECT` истории по `session_id`.
    - Реализованы асинхронные методы `add_message` (для `INSERT`) и `clear` (для `DELETE`).

### 3.2. Слой Интеграции — Интеграция с LangChain

**Цель:** Соединить хранилище с механизмами памяти LangChain.

**Действия:**
1.  **Создана "фабрика" `get_chat_memory()`:** Функция принимает `session_id`, создает экземпляр `SQLiteChatMessageHistory` и оборачивает его в `ConversationBufferWindowMemory` от LangChain, задавая "окно" памяти (`k`).
2.  **Обновлен `.gitignore`:** Добавлены файлы `*.sqlite3` и `*.sqlite3-journal` для исключения из контроля версий.

---

## Шаг 4: Реализация RAG - Логика LLM и цепочки

### 4.1. Создание Системного Промпта и Шаблона

**Цель:** Определить "личность" и инструкции для AI-ассистента в файле `app/core/chain.py`.

**Действия:**
1.  **Определен `SYSTEM_PROMPT`:** Создана многострочная константа, детально описывающая роль бота, его источники знаний (контекст и история чата) и правила поведения (не "галлюцинировать", общаться на "Вы").
2.  **Создан `ChatPromptTemplate`:** Сформирован шаблон промпта, включающий системное сообщение, плейсхолдер для истории чата (`MessagesPlaceholder`) и шаблон для вопроса пользователя с контекстом.

### 4.2. Реализация Функции-Фабрики для RAG-цепочки

**Цель:** Сконструировать исполняемую RAG-цепочку с помощью LangChain Expression Language (LCEL).

**Действия:**
1.  **Создана функция `get_rag_chain()`:**
    - Инициализирует LLM (`ChatMistralAI`) и ретривер из `ChromaDB`.
    - Строит основную RAG-цепочку, которая принимает вопрос, извлекает контекст, форматирует промпт и генерирует ответ.
    - Создает оберточную `conversational_rag_chain`, которая добавляет в процесс историю чата, загружаемую с помощью кастомной асинхронной функции `_get_async_chat_history`.

---

## Шаг 5: Интеграция с Telegram

### 5.1. Реализация и регистрация обработчиков

**Цель:** Интегрировать RAG-цепочку в Telegram-бота в файле `main.py`.

**Действия:**
1.  **Настроен `Router` в `aiogram`:** Создан экземпляр `Router` для модульной организации обработчиков.
2.  **Реализован обработчик `/start`:** Отправляет статичное приветственное сообщение.
3.  **Реализован основной обработчик сообщений:**
    - Срабатывает на все текстовые сообщения.
    - Отправляет статус "печатает" для улучшения UX.
    - Формирует `session_id` на основе `message.chat.id`.
    - Асинхронно вызывает RAG-цепочку (`rag_chain.ainvoke()`) с вопросом и `session_id`.
    - Отправляет сгенерированный ответ пользователю.
    - Явно сохраняет вопрос пользователя и ответ AI в историю чата через `memory.chat_memory.add_messages()`.

---

## Шаг 6: Рефакторинг - Переход на собственный Embedding-сервис

**Цель:** Заменить `MistralAIEmbeddings` на собственный API-сервис для устранения зависимости от сторонних лимитов и получения полного контроля над процессом.

**Стратегия:** Создание кастомного, LangChain-совместимого класса-клиента `ApiServiceEmbeddings`.

**План выполнения:**
1.  **Конфигурация:** В `.env` и `app/core/config.py` добавлена переменная `EMBEDDING_SERVICE_URL`.
2.  **Реализация клиента:** В `app/core/rag.py` создан класс `ApiServiceEmbeddings`.
3.  **Интеграция:** Фабрика `get_embedding_model()` переключена на новый класс.
4.  **Очистка:** Из `requirements.txt` удалена зависимость `langchain-mistralai`.

---

## Шаг 7: Интеграционное тестирование и отладка

### 7.1. Цель и План

Проведено интеграционное тестирование для проверки работоспособности RAG-цепочки с новым сервисом. План включал очистку старой БД, запуск индексации и параллельный мониторинг логов клиента и сервера.

### 7.2. Процесс отладки и финальное решение

В ходе тестирования были выявлены и устранены две критические ошибки:
1.  **`NotImplementedError`:** Возникла из-за того, что `ChromaDB` пыталась вызвать синхронный метод `embed_documents`, который не был реализован.
2.  **`RuntimeError: Event loop is closed`:** Появилась после промежуточного фикса с `asyncio.run()`. Причина — конфликт event loop'ов, так как `ChromaDB` выполняет код в отдельном потоке.

**Финальное решение:** Проблема была решена путем использования потокобезопасной функции `asyncio.run_coroutine_threadsafe()`. Этот подход корректно отправляет асинхронную задачу из рабочего потока `ChromaDB` на выполнение в главный event loop и дожидается результата.

### 7.3. Результаты

После внедрения финального решения скрипт индексации успешно обработал все батчи документов. Логи подтвердили корректную отправку и обработку всех API-запросов.

**Вывод:** Интеграционное тестирование пройдено успешно. RAG-система полностью работоспособна и стабильна.