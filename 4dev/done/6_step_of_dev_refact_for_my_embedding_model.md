# План рефакторинга: Интеграция собственного embedding-сервиса

**Версия:** v0.2.0
**Дата:** 2025-10-10

## 1. Цель

Заменить используемую в проекте модель эмбеддингов `MistralAIEmbeddings` на собственный API-сервис, развернутый на сервере `91.206.14.93:8000`.

**Ключевые задачи:**
- Устранить зависимость от лимитов и стоимости стороннего API для векторизации.
- Получить полный контроль над процессом создания эмбеддингов.
- Обеспечить стабильную и предсказуемую производительность RAG-системы.

## 2. Стратегия реализации

Рефакторинг будет выполнен путем создания кастомного, LangChain-совместимого класса-клиента, который инкапсулирует всю логику взаимодействия с нашим API. Это обеспечит минимальное вмешательство в уже работающую логику и сохранит чистоту архитектуры.

## 3. Пошаговый план выполнения

---

### Шаг 1: Обновление конфигурации

**Файлы:** `.env`, `app/core/config.py`

1.  **Добавить переменную в `.env`:**
    - Добавить новую строку для хранения URL нашего сервиса.
    ```dotenv
    EMBEDDING_SERVICE_URL="http://91.206.14.93:8000/embed"
    ```
2.  **Обновить `Settings` в `app/core/config.py`:**
    - Добавить поле `EMBEDDING_SERVICE_URL: str` в класс `Settings` для валидации и доступа к переменной окружения.

---

### Шаг 2: Реализация кастомного клиента `ApiServiceEmbeddings`

**Файл:** `app/core/rag.py`

1.  **Создать класс `ApiServiceEmbeddings`:**
    - Класс должен наследовать `langchain_core.embeddings.Embeddings`.
    - Конструктор `__init__` должен принимать `api_url: str` и `async_client: httpx.AsyncClient`.
2.  **Реализовать асинхронные методы:**
    - `aembed_documents(self, texts: List[str]) -> List[List[float]]`: Принимает список текстов, отправляет POST-запрос на `/embed` и возвращает список векторов.
    - `aembed_query(self, text: str) -> List[float]`: Принимает один текст, отправляет запрос и возвращает один вектор.
3.  **Обеспечить отказоустойчивость:**
    - Вся логика HTTP-запросов должна быть обернута в `try...except` для обработки `httpx.HTTPStatusError` и других сетевых исключений.

---

### Шаг 3: Интеграция клиента и удаление старого кода

**Файл:** `app/core/rag.py`

1.  **Модифицировать `get_embedding_model()`:**
    - Удалить код, связанный с созданием `MistralAIEmbeddings`.
    - Функция должна создавать и возвращать экземпляр нового класса `ApiServiceEmbeddings`, передавая ему `settings.EMBEDDING_SERVICE_URL` и `httpx.AsyncClient`.

---

### Шаг 4: Обновление зависимостей

**Файл:** `requirements.txt`

1.  **Удалить неиспользуемую зависимость:**
    - Так как `MistralAIEmbeddings` больше не используется, удалить строку `langchain-mistralai==0.1.9`.
    - Зависимость `mistralai` остается, так как она необходима для работы LLM.
2.  **Выполнить синхронизацию окружения:**
    - После изменения `requirements.txt` выполнить `pip install -r requirements.txt` для удаления пакета из виртуального окружения.

---

## 4. Тестирование и отладка

После завершения рефакторинга было проведено интеграционное тестирование путем запуска скрипта `app/core/rag.py` для полной переиндексации базы знаний. В ходе тестирования был выявлен и устранен ряд критических ошибок, связанных с взаимодействием синхронного и асинхронного кода.

### Проблема 1: `NotImplementedError`

*   **Симптом:** При первом запуске скрипт упал с ошибкой `NotImplementedError: Use 'aembed_documents' for asynchronous operation.`.
*   **Причина:** `langchain-chroma` при вызове `add_documents()` или `aadd_documents()` (который является псевдо-асинхронным) внутри себя обращается к **синхронному** методу `embed_documents` у объекта-эмбеддера. Наша первоначальная реализация `ApiServiceEmbeddings` была `async-first` и не содержала реализации этого метода.

### Проблема 2: `RuntimeError: Event loop is closed`

*   **Симптом:** После реализации `embed_documents` через `asyncio.run()` скрипт успешно обрабатывал первый батч документов, но падал на втором с ошибкой `RuntimeError: Event loop is closed`.
*   **Причина:** `ChromaDB` выполняет `embed_documents` в отдельном рабочем потоке. Функция `asyncio.run()` создает **новый** event loop, выполняет в нем задачу и **закрывает** его. Повторный вызов `asyncio.run()` в том же потоке для второго батча приводил к конфликту, так как `asyncio` не позволяет запускать новый event loop, пока старый не был полностью очищен, что и приводило к ошибке.

### Финальное решение

*   **Реализация:** Проблема была решена путем использования потокобезопасной функции `asyncio.run_coroutine_threadsafe()`.
    1.  В конструктор `ApiServiceEmbeddings` был передан главный event loop, полученный через `asyncio.get_running_loop()`.
    2.  В синхронных методах (`embed_documents`, `embed_query`) вызов асинхронной логики был обернут в `asyncio.run_coroutine_threadsafe(coro, self.loop)`.
    3.  Этот подход корректно отправляет асинхронную задачу из рабочего потока `ChromaDB` на выполнение в главный event loop и дожидается результата, не создавая конфликтов.

### Результат

После внедрения финального решения скрипт `app.core.rag` успешно обработал все 7 батчей (106 чанков) документов, что подтвердило полную работоспособность и стабильность интеграции с собственным embedding-сервисом.