# План Реализации: Шаг 3 - Модуль Памяти и Хранение Истории

## Введение
Этот план описывает последовательность действий для создания модуля персистентной памяти. Цель — наделить бота способностью помнить предыдущие сообщения в диалоге с каждым конкретным пользователем. Для этого мы реализуем механизм хранения истории чата в базе данных SQLite и интегрируем его с экосистемой LangChain. Разработка будет вестись по принципу "снизу-вверх": от слоя данных к слою интеграции.

---

### **Этап 1: Слой Данных — Взаимодействие с SQLite**

На этом этапе мы создадим низкоуровневый компонент, отвечающий за асинхронную работу с базой данных. Вся логика будет инкапсулирована в новом файле `app/core/memory.py`.

#### **1.1. Определение Констант и Зависимостей**
*   **Цель:** Централизовать пути и убедиться в наличии необходимых библиотек.
*   **Файл:** `app/core/memory.py`
*   **Логика:**
    *   Определить константу `CHAT_HISTORY_DB_PATH`, указывающую на файл `chat_history.sqlite3` в корне проекта.
    *   Импортировать необходимые компоненты: `aiosqlite`, `json`, `pathlib`, а также классы из `langchain_core.chat_history` и `langchain_core.messages`.

#### **1.2. Реализация Кастомного Хранилища Истории**
*   **Цель:** Создать класс, который реализует интерфейс LangChain для хранения сообщений и инкапсулирует всю логику работы с SQLite.
*   **Файл:** `app/core/memory.py`
*   **Класс / Сигнатура:** `class SQLiteChatMessageHistory(BaseChatMessageHistory):`
*   **Логика:**
    1.  **`__init__`**: Конструктор принимает `session_id` (ID пользователя) и `db_path`. В нем создается `async` подключение к БД и вызывается метод для инициализации таблицы.
    2.  **`_create_table_if_not_exists`**: Асинхронный приватный метод, который выполняет SQL-запрос `CREATE TABLE IF NOT EXISTS` для таблицы `chat_history` со столбцами `session_id` (TEXT), `message` (TEXT).
    3.  **`messages` (property)**: Асинхронное свойство для получения истории. Выполняет `SELECT` из БД по `session_id`, десериализует JSON-сообщения и возвращает список объектов `BaseMessage`.
    4.  **`add_message`**: Асинхронный метод, принимающий объект `BaseMessage`. Сериализует его в JSON и выполняет `INSERT` в таблицу `chat_history`.
    5.  **`clear`**: Асинхронный метод, выполняющий `DELETE` всех записей для текущего `session_id`.

---

### **Этап 2: Слой Интеграции — Интеграция с LangChain**

На этом этапе мы создадим высокоуровневые компоненты, которые соединят наше хранилище с механизмами памяти LangChain.

#### **2.1. Создание "Фабрики" Объектов Памяти**
*   **Цель:** Создать удобную функцию для получения готового к использованию объекта памяти LangChain для любого пользователя.
*   **Файл:** `app/core/memory.py`
*   **Функция / Сигнатура:** `get_chat_memory(session_id: str) -> ConversationBufferWindowMemory:`
*   **Логика:**
    1.  Функция принимает `session_id`.
    2.  Внутри создается экземпляр нашего класса `SQLiteChatMessageHistory` с переданным `session_id`.
    3.  Создается и возвращается экземпляр `ConversationBufferWindowMemory` из `langchain.memory`. В конструктор передаются:
        *   `chat_memory`: экземпляр `SQLiteChatMessageHistory`.
        *   `k`: количество последних сообщений для хранения в окне (например, 10).
        *   `return_messages=True`: чтобы память возвращала объекты `BaseMessage`, а не строки.

#### **2.2. Обновление `.gitignore`**
*   **Цель:** Предотвратить попадание файла базы данных истории чатов в репозиторий.
*   **Файл:** `.gitignore`
*   **Логика:** Добавить в файл строки `chat_history.sqlite3` и `chat_history.sqlite3-journal`.