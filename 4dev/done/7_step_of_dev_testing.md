# Шаг 7: Интеграционное тестирование RAG-системы

**Версия:** v0.3.0
**Дата:** 2025-10-10

---

## 1. Цель тестирования

Проверить корректность интеграции и работоспособность полной RAG-цепочки после замены `MistralAIEmbeddings` на собственный API-сервис эмбеддингов.

**Ключевые проверяемые компоненты:**
- Взаимодействие `langchain-chroma` с кастомным классом `ApiServiceEmbeddings`.
- Корректность сетевых запросов к API-сервису (`http://91.206.14.93:8000/embed`).
- Стабильность процесса индексации при обработке нескольких батчей данных.

---

## 2. План тестирования

1.  **Подготовка:** Очистить старую векторную базу данных для обеспечения чистоты эксперимента.
    ```bash
    rm -rf chroma_db/
    ```
2.  **Мониторинг:** В отдельном терминале запустить мониторинг логов `e5-service` на сервере для отслеживания входящих API-запросов.
    ```bash
    ssh mynamemyway@91.206.14.93
    docker logs -f e5-service
    ```
3.  **Запуск индексации:** На локальной машине запустить скрипт полной переиндексации базы знаний.
    ```bash
    python -m app.core.rag
    ```
4.  **Анализ:** Проанализировать логи на стороне клиента и сервера на предмет ошибок и подтверждения успешной обработки.

---

## 3. Процесс отладки

В ходе тестирования был выявлен и устранен ряд критических ошибок, связанных с взаимодействием синхронного и асинхронного кода.

### Проблема 1: `NotImplementedError`
*   **Причина:** `langchain-chroma` при вызове `aadd_documents()` внутри себя обращается к **синхронному** методу `embed_documents`, который не был реализован в нашем `async-first` клиенте.

### Проблема 2: `RuntimeError: Event loop is closed`
*   **Причина:** Промежуточное решение с использованием `asyncio.run()` падало на втором батче. `ChromaDB` выполняет `embed_documents` в отдельном потоке, а `asyncio.run()` создает и закрывает новый event loop при каждом вызове, что приводит к конфликту с уже запущенным главным циклом.

### Финальное решение
*   **Реализация:** Проблема была решена путем использования потокобезопасной функции `asyncio.run_coroutine_threadsafe()`. Этот подход корректно отправляет асинхронную задачу из рабочего потока `ChromaDB` на выполнение в главный event loop и дожидается результата, не создавая конфликтов.

---

## 4. Результаты

После внедрения финального решения скрипт `app.core.rag` успешно обработал все 7 батчей (106 чанков) документов. Логи на стороне клиента и сервера подтвердили корректную отправку и обработку всех API-запросов.

**Вывод:** Интеграционное тестирование пройдено успешно. RAG-система полностью работоспособна и стабильна при использовании собственного embedding-сервиса.