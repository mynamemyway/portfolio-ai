### План разработки: Модуль сбора статистики
**Цель:** Реализовать механизм для сбора, хранения и анализа данных о взаимодействии пользователей с ботом. Это позволит отслеживать количество уникальных пользователей, популярные запросы и эффективность RAG-системы.

---

### Этап 0: Корректировка кодировки в существующей БД
*   **Цель:** Исправить сохранение кириллических символов в таблице `chat_history`, чтобы текст сохранялся в читаемом виде.
*   **Файл:** `app/core/memory.py`
*   **Логика:** В методах `add_message` и `add_messages` класса `SQLiteChatMessageHistory` модифицировать вызов `json.dumps`, добавив параметр `ensure_ascii=False`.

---

### Этап 1: Слой Базы Данных и Моделей
На этом этапе мы определим структуру для хранения статистических данных. Мы будем использовать существующую базу данных SQLite, добавив в нее новую таблицу.

#### 1.1. Создание модуля для работы со статистикой
*   **Цель:** Создать отдельный модуль, инкапсулирующий всю логику взаимодействия с таблицей статистики.
*   **Файл:** `app/core/stats.py` (новый файл).
*   **Логика:**
    1.  Определить путь к базе данных, используя существующий `CHAT_HISTORY_DB_PATH` из `app/core/memory.py` для консистентности.
    2.  Реализовать асинхронную функцию `_create_table_if_not_exists()`, которая будет создавать таблицу `query_stats` со следующими полями:
        *   `id`: `INTEGER PRIMARY KEY AUTOINCREMENT`
        *   `user_id`: `INTEGER NOT NULL`
        *   `username`: `TEXT`
        *   `first_name`: `TEXT`
        *   `last_name`: `TEXT`
        *   `query_text`: `TEXT NOT NULL`
        *   `retrieved_context`: `TEXT`
        *   `llm_response`: `TEXT`
        *   `timestamp`: `DATETIME NOT NULL`
    3.  Реализовать основную асинхронную сервисную функцию `log_query(...)`, которая будет принимать данные о запросе и сохранять их в таблицу `query_stats`.

---

### Этап 2: Слой API (Схемы и Роутеры)
На данном этапе изменения не требуются. Функционал сбора статистики является внутренним процессом и не предполагает создания новых публичных API-эндпоинтов.

---

### Этап 3: Слой Сервисной Логики
На этом этапе мы интегрируем вызов новой логики сбора статистики в существующий процесс обработки запросов пользователя.

#### 3.1. Модификация RAG-цепочки для извлечения контекста
*   **Цель:** Изменить RAG-цепочку таким образом, чтобы она возвращала не только финальный ответ, но и извлеченный из векторной базы контекст.
*   **Файл:** `app/core/chain.py`
*   **Функция / Сигнатура:** `get_rag_chain()`
*   **Логика:** Модифицировать `conversational_rag_chain` так, чтобы она возвращала словарь, содержащий и ответ (`answer`), и извлеченный контекст (`context`).

#### 3.2. Интеграция логирования в обработчик запросов
*   **Цель:** Встроить вызов функции логирования в основной обработчик запросов.
*   **Файл:** `app/handlers/user_handlers.py`
*   **Функция / Сигнатура:** `process_query(...)`
*   **Логика:** После успешного выполнения `rag_chain.ainvoke()` и получения ответа с контекстом, добавить вызов `await log_query(...)` и передать в него все необходимые данные, включая `first_name` и `last_name` из объекта `message.from_user`.

---

### Этап 4: Тестирование
*   **Цель:** Проверить, что сбор статистики работает корректно и не нарушает основную логику.
*   **Логика:**
    1.  Запустить бота и отправить ему несколько текстовых запросов.
    2.  Проверить, что бот по-прежнему отвечает корректно.
    3.  С помощью SQLite-клиента открыть файл `app/db/chat_history.sqlite3`.
    4.  Убедиться, что появилась таблица `query_stats` и в ней создались записи, соответствующие отправленным запросам.
*   **Автотесты:** Написать автотесты для проверки всей логики кроме внешних запросов к LLM.

---

### Логирование статических действий

**Цель:** Расширить сбор статистики для отслеживания нажатий на кнопки, которые не вызывают LLM, для получения полной картины взаимодействия пользователя с интерфейсом.

**План реализации:**

#### Шаг 1: Модификация `app/core/stats.py`
*   **Цель:** Сделать поля `retrieved_context` и `llm_response` в функции `log_query` опциональными, чтобы можно было логировать действия без ответа от LLM.
*   **Логика:** Изменить сигнатуру функции `log_query`, присвоив параметрам `retrieved_context` и `llm_response` значение по умолчанию `None`.

#### Шаг 2: Модификация `app/handlers/user_handlers.py`
*   **Цель:** Добавить вызовы `log_query` для отслеживания нажатий на статические кнопки.
*   **Логика:** В функции `handle_main_menu_button` в соответствующие `case` (`"projects"`, `"contact"`, `"hello"`, `"about_portfolio"`, и т.д.) добавить вызов `await log_query`. В `query_text` будет записываться понятный идентификатор действия, например, `CLICK: Projects Button`.

#### Шаг 3: Логирование команд
*   **Цель:** Добавить логирование для slash-команд (`/start`, `/help`, `/reset`) для полного охвата действий пользователя.
*   **Файл:** `app/handlers/user_handlers.py`
*   **Логика:** В начало каждого обработчика команд (`handle_start`, `handle_help`, `handle_reset`) добавить вызов `await log_query` с соответствующим идентификатором, например, `COMMAND: /start`.
