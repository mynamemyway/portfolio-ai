# Руководство по созданию планов разработки

## Введение
Цель детального плана — декомпозировать сложную задачу на атомарные, последовательные шаги. Это обеспечивает предсказуемость, снижает когнитивную нагрузку и позволяет всей команде (бэкенд, фронтенд, QA) иметь единое видение реализации.

## Основной принцип: "Снизу вверх" по слоям архитектуры
План строится по слоям приложения, начиная с самого низкого (база данных) и заканчивая самым высоким (тесты). Это гарантирует, что на каждом следующем этапе у нас уже есть все необходимые компоненты с предыдущего.

**Порядок слоев:**
1.  **Слой Базы Данных и Моделей:** Определяем, как будут храниться данные.
2.  **Слой API (Схемы и Роутеры):** Проектируем "контракт" — как внешний мир будет взаимодействовать с функцией.
3.  **Слой Сервисной Логики:** Реализуем бизнес-логику, связывающую модели и API.
4.  **Тестирование:** Покрываем новый код тестами для гарантии качества.

---

## Шаблон Плана Разработки

### **Этап 1: Слой Базы Данных и Моделей**

На этом этапе мы определяем структуру данных.

#### **1.1. Обновление Модели**
*   **Цель:** Добавить в существующую модель поле для хранения нового состояния или данных.
*   **Файл:** `your_app/models.py`
*   **Функция / Сигнатура:** `class YourModel(Base): ...`
*   **Логика:** Добавить новый столбец в существующую модель SQLAlchemy. Например, булево поле с значением по умолчанию, которое будет служить "переключателем" для новой функции.

#### **1.2. Создание Миграции**
*   **Цель:** Сгенерировать и проверить скрипт миграции для безопасного обновления схемы базы данных.
*   **Файл:** `alembic/versions/`
*   **Логика:**
    1.  Выполнить команду для автоматической генерации миграции (например, `alembic revision --autogenerate -m "Your migration message"`).
    2.  Проверить сгенерированный скрипт на соответствие правилам проекта (например, использование `batch_alter_table` для совместимости с SQLite).
    3.  Применить миграцию для обновления схемы базы данных.

---

### **Этап 2: Слой API (Схемы и Роутеры)**

На этом этапе мы проектируем, как фронтенд или другие сервисы будут обращаться к новой функции.

#### **2.1. Обновление Схем Pydantic**
*   **Цель:** Создать схемы для валидации входящих и исходящих данных API.
*   **Файл:** `your_app/schemas.py`
*   **Логика:** Создать новые схемы Pydantic, специфичные для новой функции:
    *   Схему для ответа на `GET` запрос (возвращает текущее состояние).
    *   Схему для тела `PATCH` или `POST` запроса (принимает данные для обновления).

#### **2.2. Обновление Роутера**
*   **Цель:** Создать публичные эндпоинты для взаимодействия с функцией.
*   **Файл:** `your_app/api/routers/your_router.py`
*   **Логика:** Добавить новые эндпоинты для управления новой функцией:
    *   `GET /api/your-feature/endpoint`: Получение текущего состояния.
    *   `PATCH /api/your-feature/endpoint`: Обновление состояния.

---

### **Этап 3: Слой Сервисной Логики**

На этом этапе мы реализуем "мозг" нашей функции — бизнес-логику.

#### **3.1. Обновление Сервиса-помощника (CRUD)**
*   **Цель:** Создать простые функции для чтения и записи нового поля в базу данных.
*   **Файл:** `your_app/services/your_crud_service.py`
*   **Функции / Сигнатуры:**
    *   `get_your_feature_settings(db_session, model_instance)`
    *   `update_your_feature_settings(db_session, model_instance, update_data)`
*   **Логика:** Функции инкапсулируют простое чтение/запись нового поля из модели, обеспечивая разделение ответственности.

#### **3.2. Реализация Основной Бизнес-логики**
*   **Цель:** Реализовать основной сценарий использования функции.
*   **Файл:** `your_app/services/your_main_service.py`
*   **Функция / Сигнатура:** `_your_private_business_logic_func(...)`
*   **Логика:**
    1.  **Проверка условий:** Проверить, выполнены ли все условия для запуска логики (например, включена ли соответствующая настройка у пользователя).
    2.  **Формирование данных:** Подготовить данные в нужном формате (например, создать объект схемы Pydantic).
    3.  **Переиспользование:** Вызвать существующие сервисные функции для выполнения стандартных операций (например, создание другой сущности).
    4.  **Обработка ошибок:** Корректно обработать ожидаемые исключения (например, конфликт данных `409 Conflict`), чтобы предотвратить сбои.

#### **3.3. Интеграция в существующий процесс**
*   **Цель:** Встроить вызов новой логики в подходящее место существующего кода.
*   **Файл:** `your_app/services/your_main_service.py`
*   **Функция / Сигнатура:** `_existing_function_to_modify(...)`
*   **Логика:** После выполнения основной логики существующей функции, добавить вызов новой приватной функции, реализованной на предыдущем шаге.

---

### **Этап 4: Тестирование**

На этом этапе мы гарантируем, что новый код работает корректно и не ломает существующий.

#### **4.1. Тестирование API**
*   **Цель:** Проверить, что новые эндпоинты работают правильно.
*   **Файл:** `tests/api/test_your_feature.py`
*   **Логика:**
    *   Написать тест, проверяющий, что `GET` эндпоинт возвращает корректные данные по умолчанию.
    *   Написать тест, проверяющий полный цикл `PATCH`: успешное обновление, проверка сохранения и возврат к исходному состоянию.

#### **4.2. Интеграционное тестирование**
*   **Цель:** Проверить полный сценарий работы функции от начала до конца.
*   **Файл:** `tests/test_your_integration_flow.py`
*   **Логика:** Написать параметризованный тест, который проверяет все ключевые сценарии использования новой функции, включая пограничные случаи и обработку ошибок.
